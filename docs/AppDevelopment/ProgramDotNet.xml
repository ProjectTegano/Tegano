<sect1>
<title>Functions in .NET</title>
	<sect2>
		<title>Introduction</title>
		<para>You can write functions for the logic tier of <application>Wolframe</application> in languages based
		on <application>.NET</application> (<ulink url="http://www.microsoft.com/net">http://www.microsoft.com/net</ulink>) like for example
		<application>C#</application> and <application>VB.NET</application>.  
		Because <application>.NET</application> based libraries can only be called 
		by <application>Wolframe</application> only as a 
		compiled and not as an interpreted language, you have to build a module out of your function 
		implementation.
		</para>
	</sect2>

	<sect2>
	<title>Configuration</title>
	<para>For enabling .NET you have to declare the loading of the module 'mod_command_dotnet'
		in the main section of the server configuration file.
		<programlisting language='awk'>
		<xi:include  xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/AppDevelop/cfg_command_dotnet.conf" parse="text" />
		</programlisting>
		For the configuration of the .NET assemblies to be loaded, see section 'Configure .NET Modules'.
	</para>
	</sect2>

	<sect2>
		<title>Restrictions</title>
		<para>
		Currently <application>.NET</application> procedures called from Wolframe
		cannot call other Wolframe functions.
		But we will provide the possibility to call Wolframe global function calls
		like for example transaction function calls from <application>.NET</application>
		soon.
		</para>
	</sect2>

	<sect2>
	<title>Prepare .NET Modules</title>
	<para>
	To make functions written in .NET callable by Wolframe, several steps have to be performed.
	First the asseblies with the functions exported to Wolframe have to be build COM visible.
	Wolframe itself is not a .NET application. Therefore it has to call .NET functions via
	COM/.NET interop interface of the CLR.
	</para>
		<sect3>
		<title>Make Assemblies COM visible</title>
		<para>To make the .NET functions called from Wolframe COM visible, you have to tick
		"Properties/Assembly Information" the switch "Make assembly COM visible". Furthermore
		every object and method that is part of the exported API (also objects used as parameters)
		has to be tagged in the source as COM visible with <code>[ComVisible(true)]</code>.
		</para>
		</sect3>

		<sect3>
		<title>Tag Exported Objects with a Guid</title>
		<para>Each object that is part of the exported API has to be tagged with a global unique
		identifier (Guid) in order to be adressable. Modules with .NET functions will have to be globally
		registered and the objects need to be identified by the Guid because that's the only way
		to make the record info structure visible for Wolframe. The record info structure is
		needed to serialize/deserialize .NET objects from another interpreter context that
		is not registered for .NET. There are many ways to create a Guid and
		tag an object like this: <code>[Guid("390E047F-36FD-4F23-8CE8-3A4C24B33AD3")]</code>.
		</para>
		</sect3>

		<sect3>
		<title>Add Marshalling Tags to Values</title>
		<para>For marshalling function calls correctly, Wolframe needs
		tags for every parameter and member of a sub structure of a parameter
		of methods exported as functions.
		The following table lists the supported types and their marshalling tags:
		</para>
		<table frame="all" width="100%">
			<title>Marshalling Tags</title>
			<tgroup cols="2">
			<colspec colnum="1" colwidth="1*"/>
			<colspec colnum="2" colwidth="2*"/>
			<thead>
			<row>
				<entry>.NET Type</entry>
				<entry>Marshalling Tag</entry>
			</row>
			</thead>

			<tbody>
			<row>
				<entry>I2</entry>
				<entry><code>[MarshalAs(UnmanagedType.I2)]</code></entry>
			</row>
			<row>
				<entry>I4</entry>
				<entry><code>[MarshalAs(UnmanagedType.I4)]</code></entry>
			</row>
			<row>
				<entry>I8</entry>
				<entry><code>[MarshalAs(UnmanagedType.I8)]</code></entry>
			</row>
			<row>
				<entry>UI2</entry>
				<entry><code>[MarshalAs(UnmanagedType.UI2)]</code></entry>
			</row>
			<row>
				<entry>UI4</entry>
				<entry><code>[MarshalAs(UnmanagedType.UI4)]</code></entry>
			</row>
			<row>
				<entry>UI8</entry>
				<entry><code>[MarshalAs(UnmanagedType.UI8)]</code></entry>
			</row>
			<row>
				<entry>R4</entry>
				<entry><code>[MarshalAs(UnmanagedType.R4)]</code></entry>
			</row>
			<row>
				<entry>R8</entry>
				<entry><code>[MarshalAs(UnmanagedType.R8)]</code></entry>
			</row>
			<row>
				<entry>BOOL</entry>
				<entry><code>[MarshalAs(UnmanagedType.BOOL)]</code></entry>
			</row>
			<row>
				<entry>string</entry>
				<entry><code>[MarshalAs(UnmanagedType.BStr)]</code></entry>
			</row>
			<row>
				<entry>RECORD</entry>
				<entry><para>no tag needed</para></entry>
			</row>
			<row>
				<entry>array of structures</entry>
				<entry><code>[MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_RECORD)]</code></entry>
			</row>
			<row>
				<entry>array of strings</entry>
				<entry><code>[MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_BSTR)]</code></entry>
			</row>
			<row>
				<entry>array of XX (XX=I2,I4,I8,..)</entry>
				<entry><code>[MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_XX)]</code></entry>
			</row>
			</tbody>
			</tgroup>
		</table>
		<para>Decimal floating point and numeric types (DECIMAL) are not yet supported, but
		will soon be available.</para>
		</sect3>

		<sect3>
		<title>Create a Type Library</title>
		<para>For making the API introspectable by Wolframe, we have to create a TLB
		(Type Library) file from the assembly (DLL) after build. The type library has
		to be recreated every time the module interface (API) changes. The type library is
		created with the program <code>tlbexp</code>. All created type library (.tlb) file
		that will be loaded with the same runtime environment have to be copied into
		the same directory. They will be referenced for introspection in the 
		configuration. The configuration of .NET will be explained later.
		</para>
		</sect3>

		<sect3>
		<title>Register the Type Library</title>
		<para>The type library created with <code>tlbexp</code> has also to be registered.
		For this you call the program <code>regtlibv12</code> with your type library file
		(.tlb file) as argument. The type libary fegistration has to be repeated when
		the the module interface (API) changes.
		</para>
		</sect3>

		<sect3>
		<title>Register the Assembly in the GAC</title>
		<para>Wolframe does not accept local assemblies. In order to be addressable over
		the type library interface assemblies need to be put into the global assembly cache (GAC).
		Unfortunately this has to be repeated every time the assembly binary changes.
		There is no way around. For registration in the GAC you have to call the program
		<code>gacutil /if &lt;assemblypath&gt;</code> with your assembly path &lt;assemblypath&gt;
		as argument. Furthermore the command <code>gacutil</code> has to be called from
		administrator command line.
		</para>
		</sect3>
	</sect2>

	<sect2>
	<title>Configure .NET Modules</title>
	<para>
	.NET modules are grouped together in a configuration block that specifies the configuration
	of the Microsoft Common Language Runtime (CLR) used for .NET interop calls. The configuration
	block has the header <code>runtimeEnv dotNET</code> and configures the version of the 
	runtime loaded and the path where the typelibraries (.tlb) files can be found. 
	With the <code>assembly</code> definitions you declare the registered assemblies to load.
	<programlisting language='cfg'>
	<xi:include  xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/AppDevelop/cfg_program_dotnet.conf" parse="text" />
	</programlisting>
	</para>
	</sect2>
	<para></para>
</sect1>

