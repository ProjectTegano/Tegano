<!-- Introduction -->
<chapter>
	<title>Introduction</title>
	<para>
	First we describe the overall architecture and the data flow in a <application>Wolframe</application> application.
	</para>

	<sect1>
		<title>Architecture</title>
		<para><application>Wolframe</application> is a 3-tier application server.
		</para>
		<figure>
			<title>Overview</title>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/3-tier.svg" format="SVG"
						scalefit="1" width="100%" contentdepth="100%"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="images/3-tier.png" format="PNG"/>
				</imageobject>
				<caption><para></para></caption>
			</mediaobject>
		</figure>
		<para></para>
		<sect2>
		<title>Presentation tier</title>
		<para>The presentation tier of <application>Wolframe</application> is implemented as a thin client.
			It maps the presentation of the application from the request answers it gets from the server.
			For some clients the data describing this mapping can also be loaded from the server when connecting to it.
			The whole processing ot the application is made by the server.
		</para>
		</sect2>
		<sect2>
		<title>Logic tier</title>
			<para>The logic tier of <application>Wolframe</application>
			defines the processing of data and the rules for access control
			with a configurable mechanisms for authorization.
			</para>
			<sect4>
			<title>Access control</title>
			<para>A client that logs into the system passes an authentication 
			procedure. The authorization defines the rules for privileges to 
			execute functions or accessing resources based on authentication.
			The chapter AAAA (Authentication,Authorization,Auditing,Accounting)
			will introduce the several aspects covered by Wolframe besides data
			processing.
			</para>
			</sect4>
			<sect4>
			<title>Data processing</title>
			<para>
			A client that passed authorization can send commands to the server.
			A command consists of a name plus a structured content also called 
			document.
			The server returns a single document to the presentation tier as answer.
			Many different programming/scripting languages are supported 
			to define the input/output mapping between the layers. 
			<application>Wolframe</application> introduces three concepts as 
			data processing building blocks of the logic tier:
				<itemizedlist>
					<listitem><para><glossterm>Filters</glossterm>: Filters are transforming serialized input data (XML,JSON,CSV,etc.) to a unified serialization of hierarchically structured data and to serialize any form of processed data for output. Filters are implemented as loadable modules (e.g. XML filter based on libxml2, JSON filter based on cJSON) or as scripts based on a filter module (XSLT filter script for rewriting input or output)</para></listitem>
					<listitem><para><glossterm>Forms</glossterm>: Forms are data structures defined in a data definition language (DDL). Forms are used to validate and normalize input (XML validation, token normalization, structure definition). The recommended definition of a command in the logic tier has a form to validate its input and a form to validate its output before returning it to the caller.</para></listitem>
					<listitem><para><glossterm>Functions</glossterm>: Functions delegate processing to the data tier (transactions) or they are simple data transformations or they serve as interface to integrate with other environments (e.g. <application>.NET</application>). Functions have a unique name and are called with a structure as argument and a structure as result. Functions can call other functions for delegation, e.g. a transaction definition can call a .NET function for preprocessing its input or a .NET function can call a Python function to do parts of the processing.</para></listitem>
				</itemizedlist>
			</para>
			</sect4>
			<para>You will find in this book a detailed description of the logic tier 
			and how it is used.</para>
		</sect2>
		<sect2>
		<title>Data tier</title>
			<para>The data tier of <application>Wolframe</application> defines the functions for calling a transaction.
			The main transaction function gets a complete description of the transaction to execute as input and returns
			all results of the transaction as output. The logic tier builds the result data structure out of this result
			and completes other actions defined as part of the transaction (like audit).
			The main transaction function is stateless and an abstraction of the transactional context. (The transaction
			context does not exist outside this function. Explained differently: Two functions do not refer to the same
			transaction).</para>
		</sect2>
	</sect1>

	<sect1>
		<title>Application server requests</title>
		<para><application>Wolframe</application> application server requests consist of a named command and a structured
		content (document) as argument.
		</para>
		<para>The following illustration shows the processing of one client request to the server.
			A call of the <application>Wolframe</application> logic tier gets to a command handler
			that calls functions given by the provider to perform the transaction
			requested.
		</para>
		<figure>
			<title>Overview</title>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/LogicTier.svg" format="SVG"
						scale="300"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="images/LogicTier.png" format="PNG"/>
				</imageobject>
				<caption><para></para></caption>
			</mediaobject>
		</figure>
		<para>
			In the following chapter will describe now the <application>Wolframe</application> standard command handler and how it is configured.
			Then we will show how to write programs that declare the functions executing the requests 
			and how you link them to your application.
		</para>
	</sect1>
</chapter>
