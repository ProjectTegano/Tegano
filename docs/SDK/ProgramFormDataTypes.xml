<sect1>
<title>Defining Data Structures for Forms</title>
	<sect2>
	<title>Introduction</title>
	<para>Forms defined by DDLs are typed. The only predefined type is 'string' that is neither
		validated nor transformed for processing in any way. The types that can be used in DDLs are
		defined in files with the extension ".wnmp" and defined as programs in the configuration.
	</para>
	<para>
		A .wnmp file contains assignments of type names to sequences of normalization
		function calls. Each normalization step validates the input as atomic type (arithmetic,string,etc.)
		and transforms it to another atomic type. The following normalization step takes the output of the
		previous one as input.
	</para>
	</sect2>
	<sect2>
	<title>Example</title>
	<para>
		The example defines 3 numeric types including trimming of the input string for mode tolerant
		parsing and a string type that is converted to lowercase as normalization.
	</para>
	<para>
		<programlisting language='text'>
		<xi:include  xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/example_1.normalize" parse="text" />
		</programlisting>
	</para>
	</sect2>
	<sect2>
	<title>Syntax as EBNF</title>
	<para>The declaration of a type starts with an identifier followed by an assignment operator '='
		and a comma separated sequence of ':' separated identifier tuples, defining the name
		of the normalization module (1st) and the name of the function (2nd).
		The type declaration is closed with a semicolon ';'.</para>

		<productionset>
		<title>Tokens</title>

		<production xml:id="normIdentifier" continuation='restarts'>
		<lhs>Identifier</lhs>
		<rhs>
			( ['A'-'Z'] | ['a'-'z'] | ['0'-'9'] | '_' ) +
		</rhs>
		</production>
		</productionset>

		<productionset>
		<title>Declarations</title>

		<production xml:id="normNamespace">
		<lhs>Namespace</lhs>
		<rhs>
			<nonterminal def="#normIdentifier">Identifier</nonterminal>
			':'
		</rhs>
		</production>

		<production xml:id="normNormalizeCall">
		<lhs>Call</lhs>
		<rhs>
			(
			  (
			    <nonterminal def="#normNamespace">Namespace</nonterminal>
			    <nonterminal def="#normIdentifier">Identifier</nonterminal>
			  )
			|
			  <nonterminal def="#normIdentifier">Identifier</nonterminal>
			)
		</rhs>
		</production>

		<production xml:id="normNormalizeSeq">
		<lhs>CallSeq</lhs>
		<rhs>
			(
			  (
			    <nonterminal def="#normNormalizeCall">Call</nonterminal>
			    ','
			    <nonterminal def="#normNormalizeSeq">CallSeq</nonterminal>
			  )
			|
			  <nonterminal def="#normNormalizeCall">Call</nonterminal>
			)
		</rhs>
		</production>

		<production xml:id="normTypedef">
		<lhs>Typedef</lhs>
		<rhs>
			<nonterminal def="#normIdentifier">Identifier</nonterminal>
			'='
			  <nonterminal def="#normNormalizeSeq">CallSeq</nonterminal>
			';'
		</rhs>
		</production>

		<production xml:id="normProgram">
		<lhs>Program</lhs>
		<rhs>
			(
			  (
			    <nonterminal def="#normTypedef">Typedef</nonterminal>
			    <nonterminal def="#normProgram">Program</nonterminal>
			  )
			|
			  <nonterminal def="#normTypedef">Typedef</nonterminal>
			)
		</rhs>
		</production>

		</productionset>
	</sect2>
	<para></para>
</sect1>
<beginpage/>

