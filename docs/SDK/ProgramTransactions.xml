<sect1>
<title>Defining Database Transactions</title>
	<sect2>
		<title>Introduction</title>
		<para><code>Wolframe</code> transactions are defined as functions in a transactional context.
			The 'begin' and the 'commit' or 'abort' are done automatically at the begin
			or at the end of a transaction function respectively,
			if not explicitely defined otherwise by the caller script.
			For the description of transactions <code>Wolframe</code> provides the definition
			language (TDL) introduce here.
			A transaction takes a structure as input and returns a structure as output.
		</para>
		<para>
			The transaction definition language defines a transaction as a sequence of database operations. A database operation is either a single database instruction (SELECT,UPDATE,etc.) or a name of a procedure declared in the database or a block of operations delared with OPERATION. It adds some constructs to address input structure elements or database command results as arguments.
			Each database command result can be declared as being part of the transaction result structure.
			The language has no control structures and is therefore not a general purpose programming language.
			It just offers some mapping of input to commands and from commands results to output.
		</para>
		<para>
			For input data conversion the transaction definition language lets you define a
			preprocessing section where wolframe functions defined can be called for selected input.
		</para>
	</sect2>
	<sect2>
		<title>First example</title>
		<para>This example selects a key from a table and uses it for an insert into a list. The substitute "$1" refers to the first column of the "SELECT id FROM UserTable .." query result. The substitute "$(name)" in the first statement refers to the toplevel element 'name' of the input. In the second statement it refers to the "name" element of the "item" selection in the query, e.g. for each element with the path "/item/name" (name beeing unique per item and item describing a set of items).
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/first_example.tdl" parse="text" />
		</programlisting>
		</para>
	</sect2>
	<sect2>
		<title>Description of keywords</title>
		<para>
			<simplelist type="horiz" columns="2">
			<member>TRANSACTION</member><member>Defines a block of statements in the following BEGIN ... END block as transaction.</member>
			<member>AUTHORIZE</member><member>Followed by a pair of identifiers in '(' ')' brackets, separated by a comma. Defines the method to call for granting authorization to the caller of this transaction.</member>
			<member>OPERATION</member><member>Defines a block of statements in the following BEGIN ... END block as single operation.</member>
			<member>PREPROCESS</member><member>Defines a block of preprocessing statements for processing selected input and writing into the input structure for further processing.</member>
			<member>BEGIN</member><member>Marks the start of an execution block defined as TRANSACTION or OPERATION or PREPROCESS</member>
			<member>END</member><member>Marks the end of an execution block.</member>
			<member>RESULT</member><member>Followed by a INTO name defining a relative path in result where the following block marked with BEGIN .. END is mapped to</member>
			<member>FOREACH</member><member>Followed by a selection path. Defines a selection in nodes as input of the associated command. The associated command is executed for each member of the selection. All relative path expressions in the associated command arguments have the path of a selected element of the operation as base.</member>
			<member>INTO</member><member>Followed by an identifier or a path that declares the result tag for each result element of the associated command</member>
			<member>DO</member><member>Starts the operation declaration. It is followed by an embedded SQL command terminated with ';' or by an operation call</member>
			<member>UNIQUE</member><member>constraint on operation result: Result must be unique, if it exists</member>
			<member>NONEMPTY</member><member>constraint on operation result: Result must not be empty</member>
			<member>LET</member><member>Starts a variable declaration for the current scope</member>
			<member>ON ERROR</member><member>Starts a declaration for a hint for a certain error class to enrich error messages with context information of the current operation</member>
			<member>HINT</member><member>Declares an error message in an ON ERROR &lt;errclass&gt; HINT declaration</member>
			<member>PRINT</member><member>Declares a print of an argument into the result context of the print declaration scope. The argument can be a variable or result reference but cannot refer to input. The print instruction can use an INTO path as well to declare a target path in the result</member>
			</simplelist>
		</para>
	</sect2>
	<sect2>
		<title>Substitutes in database commands and argument lists of operations</title>
		<para>
			List of Substitutes
			<simplelist type="horiz" columns="3">
			<member>Element</member><member>Example</member><member>Description</member>
			<member>$NNN</member><member>$1</member><member>Column of a row of the last result addressed by index (counted from 1 for the first column). A command containing any result reference is executed for each row of the last result</member>
			<member>$columname</member><member>$id</member><member>Column of a row of last result addressed by name. A command containing any result reference is executed for each row of the last result</member>
			<member>$(path)</member><member>$(persone/id)</member><member>Single element addressed by relative path from the current input selection</member>
			<member>$[varname]</member><member>$[id]</member><member>Variable reference refering to a single result or NULL (not a set!) previously in the same scope declared with LET varname = &lt;result column reference&gt;;</member>
			</simplelist>
		</para>
	</sect2>
	<sect2>
		<title>EBNF of the transaction definition language</title>

		<productionset>
		<title>Tokens</title>

		<production xml:id="Identifier">
		<lhs>Identifier</lhs>
		<rhs>
			( ['A'-'Z'] | ['a'-'z'] | ['0'-'9'] | '_' ) +
		</rhs>
		</production>

		<production xml:id="Number">
		<lhs>Number</lhs>
		<rhs>
			( ['0'-'9'] ) +
		</rhs>
		</production>

		<production xml:id="Selection">
		<lhs>Selection</lhs>
		<rhs>
			(
				( '/' | '//' | )
				( Identifier | '..' )
				( <nonterminal def="#Selection">Selection</nonterminal> | )
			)
		</rhs>
		</production>

		<production xml:id="Argument">
		<lhs>Argument</lhs>
		<rhs>
			'$'
			( <nonterminal def="#Number">Number</nonterminal>
			| '(' <nonterminal def="#Selection">Selection</nonterminal> ')'
			)
		</rhs>
		</production>
		</productionset>

		<productionset>
		<title>Statements</title>

		<production xml:id="Destination">
		<lhs>Destination</lhs>
		<rhs>
			'INTO'
			<nonterminal def="#Identifier">Identifier</nonterminal>
		</rhs>
		</production>

		<production xml:id="Foreach">
		<lhs>Foreach</lhs>
		<rhs>
			'FOREACH'
			<nonterminal def="#Selection">Selection</nonterminal>
		</rhs>
		</production>

		<production xml:id="EmbeddedOp">
		<lhs>EmbeddedOp</lhs>
		<rhs>
			SQLStatement
		</rhs>
		</production>

		<production xml:id="ArgumentLst">
		<lhs>ArgumentLst</lhs>
		<rhs>
			( <nonterminal def="#Argument">Argument</nonterminal> ','
			  <nonterminal def="#ArgumentLst">ArgumentLst</nonterminal>
			|
			  <nonterminal def="#Argument">Argument</nonterminal>
			)
		</rhs>
		</production>

		<production xml:id="NamedOp">
		<lhs>NamedOp</lhs>
		<rhs>
			<nonterminal def="#Identifier">Identifier</nonterminal>
			'('
				( <nonterminal def="#ArgumentLst">ArgumentLst</nonterminal> | )
			')'
		</rhs>
		</production>

		<production xml:id="Action">
		<lhs>Action</lhs>
		<rhs>
			'DO'
				(
					<nonterminal def="#EmbeddedOp">EmbeddedOp</nonterminal>
				|	<nonterminal def="#NamedOp">NamedOp</nonterminal>
				)
		</rhs>
		</production>

		<production xml:id="Statement">
		<lhs>Statement</lhs>
		<rhs>
			( <nonterminal def="#Destination">Destination</nonterminal> | )
			( <nonterminal def="#Foreach">Foreach</nonterminal> | )
			<nonterminal def="#Action">Action</nonterminal>
			';'
		</rhs>
		</production>
		</productionset>

		<productionset>
		<title>Transactions</title>

		<production xml:id="StatementLst">
		<lhs>StatementLst</lhs>
		<rhs>
			( <nonterminal def="#Statement">Statement</nonterminal>
			|  <nonterminal def="#Statement">Statement</nonterminal>
			   <nonterminal def="#StatementLst">StatementLst</nonterminal>
			)
		</rhs>
		</production>

		<production xml:id="OpBody">
		<lhs>OpBody</lhs>
		<rhs>
			'BEGIN'
			<nonterminal def="#StatementLst">StatementLst</nonterminal>
			'END'
		</rhs>
		</production>

		<production xml:id="Operation">
		<lhs>Operation</lhs>
		<rhs>
			'OPERATION' <nonterminal def="#Identifier">Identifier</nonterminal>
			( 'RESULT' 'INTO' <nonterminal def="#Identifier">Identifier</nonterminal> | )
			<nonterminal def="#OpBody">OpBody</nonterminal>
		</rhs>
		</production>

		<production xml:id="Transaction">
		<lhs>Transaction</lhs>
		<rhs>
			'TRANSACTION' <nonterminal def="#Identifier">Identifier</nonterminal>
			( 'RESULT' 'INTO' <nonterminal def="#Identifier">Identifier</nonterminal>
			| 'AUTHORIZE' '(' <nonterminal def="#Identifier">Identifier</nonterminal> ','
					<nonterminal def="#Identifier">Identifier</nonterminal> ')'
			| )
			<nonterminal def="#OpBody">OpBody</nonterminal>
		</rhs>
		</production>

		<production xml:id="Program">
		<lhs>Program</lhs>
		<rhs>
			(
			  <nonterminal def="#Transaction">Transaction</nonterminal>
			| <nonterminal def="#Operation">Operation</nonterminal>
			)
			(
			  <nonterminal def="#Program">Program</nonterminal>
			| )
		</rhs>
		</production>


		</productionset>
	</sect2>
</sect1>

