<sect1>
<title>Functions in Transaction Definition Language (TDL)</title>
	<sect2>
		<title>Introduction</title>
		<para>
			For the description of transactions <application>Wolframe</application> provides the
			transaction definition language (<acronym>TDL</acronym>) introduced here.
			<application>Wolframe</application> transactions in <acronym>TDL</acronym> are defined as functions in a
			transactional context. This means that whatever is executed in a transaction function
			belongs by default to a transaction with an auto-commit on function completion
			if not explicitely defined otherwise by the caller.
		</para>
		<para>
			A <acronym>TDL</acronym> transaction function takes a structure as input and returns a structure as output.
			The <application>Wolframe</application> database interface defines a transaction as context where input is passed as structure and the output is fetched from as structure.
			The TDL is a programming language to describe the building of transaction input and the building of the result structure from the database output.
			It defines a transaction as a sequence of database operations. A database operation is either a single embedded database instruction in the language of the underlaying database, a name of a procedure declared in the database or a block of operations delared with OPERATION. It adds some constructs to address input structure elements or database command results as arguments.
			Each database command result can be declared as being part of the transaction result structure.
			The language has no control structures and is therefore not a general purpose programming language.
			It just offers some mapping of input to commands and from commands results to output.
		</para>
		<para>
			For input data conversion the transaction definition language lets you define a
			preprocessing section where wolframe functions defined can be called for selected input.
		</para>
		<para>
			The TDL is case insensitive. For clearness and better readability TDL keywords are written in
			uppercase here.
		</para>
	</sect2>
	<sect2>
		<title>Examples</title>
		<sect3>
		<title>First</title>
		<para>This example selects a key from a table and uses it for an insert into a list. The substitute "$1" refers to the first column of the "SELECT id FROM UserTable .." query result. The substitute "$(name)" in the first statement refers to the toplevel element 'name' of the input. In the second statement it refers to the "name" element of the "item" selection in the query, e.g. for each element with the path "/item/name" (name beeing unique per item and item describing a set of items).
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/first_example.tdl" parse="text" />
		</programlisting>
		</para>
		</sect3>
		<sect3>
		<title>Preprocessing Input</title>
		<para>The example selects are id's depending on a normalized name. The normalization is done in a preprocessing step
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/preprocess_example.tdl" parse="text" />
		</programlisting>
		</para>
		</sect3>
		<sect3>
		<title>Using Variables</title>
		<para>The example returns the 'id' of a country depending on a normalized name. The normalization is done in a preprocessing step. The result is printed into a structure country/code;
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/variable_example.tdl" parse="text" />
		</programlisting>
		</para>
		</sect3>
		<sect3>
		<title>Operations (Subroutines)</title>
		<para>The example calls an operation with one argument to map the output.
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/operation_example.tdl" parse="text" />
		</programlisting>
		</para>
		</sect3>
	</sect2>
	<sect2>
	<title>Language Description</title>
		<para>
		A TDL Program consists of subroutine declarations as OPERATION blocks and exported
		function declarations as TRANSACTION blocks. OPERATION blocks have the same
		structure as TRANSACTION blocks but without preprocessing blocks and authotization
		method declarations.
		</para>
		<sect3>
			<title>OPERATION declarations</title>
			<para>A subroutine declaration starts with the Keyword <code>OPERATION</code> followed
			by the subroutine name. After this header and an optional result substructure
			name declaration, the code definition block follows starting with <code>BEGIN</code>,
			ending with <code>END</code>.
			<programlisting language='sql'>
			OPERATION &lt;name&gt;
			RESULT INTO &lt;result-block-name&gt;
			BEGIN
				...&lt;database or subroutine calls&gt;...
			END
			</programlisting>
			The line with the RESULT INTO declaration is optional.
			</para>
		</sect3>

		<sect3>
			<title>TRANSACTION declarations</title>
			<para>A transaction function declaration starts with the Keyword <code>TRANSACTION</code> followed
			by the transaction function name. This name identifies the function globally.
			The body of the function contains the following parts:
			<itemizedlist>
				<listitem><code>AUTHORIZE ( &lt;auth-function&gt;, &lt;auth-resource&gt; )</code>
					<para>
						This optional definition is dealing with 
						authorization and access rights.
					</para>
				</listitem>
				<listitem><code>RESULT INTO &lt;result-block-name&gt; FILTER &lt;post-filter-name&gt;</code>
					<para>
						This optional declaration defines a top level tag for the 
						result structure and optionally a post processing step as
						filter referenced by name.
						It is similar as the construct in the OPERATION block description
						except that you cannot specify a postprocessing filter in
						an OPERATION block.
					</para>
				</listitem>
				<listitem><code>PREPROCESS BEGIN &lt;...preprocessing function calls...&gt; END</code>
					<para>
						This optional block contains function calls on the transaction
						function input. The result of these preprocessing function calls are
						put into the input structure, so that they can be refered to in the main
						code definition block of the transaction.
						You can call any global normalization or form function in the 
						preprocessing block to enrich the input to process.
					</para>
				</listitem>
				<listitem><code>BEGIN &lt;...database or subroutine calls...&gt; END</code>
					<para>
					The main processing block starts with <code>BEGIN</code> and
					ends with <code>END</code>. It contains all the database instructions
					needed for completing this transaction.
					</para>
				</listitem>
			</itemizedlist>
			The following pseudo code snippet shows the explained building
			blocks together:
			<programlisting language='sql'>
	
			TRANSACTION &lt;name&gt;
			AUTHORIZE ( &lt;auth-function&gt;, &lt;auth-resource&gt; )
			RESULT INTO &lt;result-block-name&gt; FILTER &lt;post-filter-name&gt;
			PREPROCESS
			BEGIN
				...&lt;preprocessing function calls&gt;...
			END
			BEGIN
				...&lt;database or subroutine calls&gt;...
			END
			</programlisting>
			The lines with AUTHORIZE and RESULT INTO and FILTER declarations are optional.
			So is the preprocessing block PREPROCESS..BEGIN..END. A simpler transaction
			function looks like the following:
			<programlisting language='sql'>
	
			TRANSACTION &lt;name&gt;
			BEGIN
				...&lt;database or subroutine calls&gt;...
			END
			</programlisting>
			</para>
		</sect3>
		<sect3>
		<title>Keywords</title>
		<para>
			<simplelist type="horiz" columns="2">
			<member>TRANSACTION</member><member>Defines a block of statements in the following BEGIN ... END block as transaction.</member>
			<member>AUTHORIZE</member><member>Followed by a pair of identifiers in '(' ')' brackets, separated by a comma. Defines the method to call for granting authorization to the caller of this transaction.</member>
			<member>OPERATION</member><member>Defines a block of statements in the following BEGIN ... END block as single operation.</member>
			<member>PREPROCESS</member><member>Defines a block of preprocessing statements for processing selected input and writing into the input structure for further processing.</member>
			<member>BEGIN</member><member>Marks the start of an execution block (terminated by END) of a TRANSACTION or OPERATION or PREPROCESS or RESULT INTO block.</member>
			<member>END</member><member>Marks the end of an execution block.</member>
			<member>RESULT</member><member>Defines subsection of the result built. It is followed by a INTO and an identifier defining a relative path in result where the following block marked with BEGIN .. END is mapped to</member>
			<member>FOREACH</member><member>Followed by a selection path. Defines a selection in nodes as input of the associated command. The associated command is executed for each member of the selection. All relative path expressions in the associated command arguments have the path of a selected element of the operation as base.</member>
			<member>INTO</member><member>Followed by an identifier or a path that declares the result tag for each result element of the associated command</member>
			<member>DO</member><member>Starts a database command or execute operation declaration. It is followed by an embedded SQL command terminated with ';' or by an operation call</member>
			<member>UNIQUE</member><member>constraint on a database command or operation result: Result must be unique, if it exists</member>
			<member>NONEMPTY</member><member>constraint on a database command result: Result must not be empty</member>
			<member>LET</member><member>Starts a variable declaration for the current scope. Variables can refer to single database command results.</member>
			<member>ON ERROR</member><member>Starts a declaration for a hint for a certain error class to enrich error messages with context information of the current operation</member>
			<member>HINT</member><member>Declares an error message in an ON ERROR &lt;errclass&gt; HINT declaration</member>
			<member>PRINT</member><member>Declares a print of an argument into the result context of the print declaration scope. The argument can be a variable or result reference but cannot refer to input. The print instruction can use an INTO path as well to declare a target path in the result</member>
			</simplelist>
		</para>
		</sect3>
		<sect3>
		<title>Substitutes in Commands</title>
		<para>
			List of Substitutes
			<simplelist type="horiz" columns="3">
			<member>Element</member><member>Example</member><member>Description</member>
			<member>$NNN</member><member>$1</member><member>Column of a row of the last result addressed by index (counted from 1 for the first column). A command containing any result reference is executed for each row of the last result</member>
			<member>$columname</member><member>$id</member><member>Column of a row of last result addressed by name. A command containing any result reference is executed for each row of the last result</member>
			<member>$(path)</member><member>$(person/id)</member><member>Single element addressed by relative path from the current input selection</member>
			<member>$[varname]</member><member>$[id]</member><member>Variable reference refering to a single result or NULL (not a set!) previously in the same scope declared with LET varname = &lt;result column reference&gt;;</member>
			</simplelist>
		</para>
		</sect3>
	</sect2>
</sect1>

