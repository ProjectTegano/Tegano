<sect1>
<title>Functions in Transaction Definition Language (TDL)</title>
	<sect2>
		<title>Introduction</title>
		<para>
			For the description of transactions <application>Wolframe</application> provides the
			transaction definition language (<acronym>TDL</acronym>) introduced here.
			<application>Wolframe</application> transactions in <acronym>TDL</acronym> are defined as functions in a
			transactional context. This means that whatever is executed in a transaction function
			belongs by default to a transaction with an auto-commit on function completion
			if not explicitely defined otherwise by the caller.
		</para>
		<para>
			A <acronym>TDL</acronym> transaction function takes a structure as input
			and returns a structure as output.
			The <application>Wolframe</application> database interface defines 
			a transaction as context where input is passed as structure 
			and the output is fetched from as structure.
		</para>
		<para>
			TDL is a programming language to describe the building of transaction 
			input and the building of the result structure from the database output.
			It defines a transaction as a sequence of instructions on multiple data.
			An instruction is either discribed as a single embedded database command
			in the language of the underlaying database, a name of a function declared
			in the database (e.g. a PLSQL function) or a TDL subroutine call.
		</para>
		<para>
			Instruction on multiple data means that the instruction is executed
			for every item of an input set. This set can consist of the set of
			results of the previous instruction or one uniquely addressable
			tuple of elements in the input of the transaction function.
			The uniquely addressable input tuple can be made to a set 
			when the instruction is attributed with a foreach quantifier 
			that may address multiple elements of the function input.
		</para>
		<para>
			Each instruction result can be declared as being part of the transaction
			result structure. The language has no control structures and is 
			therefore not a general purpose programming language.
			It just offers some mapping of input to commands and from commands 
			results to output.
		</para>
		<para>
			For input data conversion the transaction definition language lets 
			you define a preprocessing section where globally defined wolframe
			functions can be called for selected input. For building an output 
			structure that cannot be modeled with a language without control
			structures and recursion TDL provides the possibility to call a
			globally defined function as filter for postprocessing of the
			transaction function result.
		</para>
		<para>
			The TDL is case insensitive. For clearness and better readability
			TDL keywords are written in uppercase here.
		</para>
	</sect2>
	<sect2>
		<title>Examples</title>
		<sect3>
		<title>First</title>
		<para>This example selects a key from a table and uses it for an insert into a list. The substitute "$1" refers to the first column of the "SELECT id FROM UserTable .." query result. The substitute "$(name)" in the first statement refers to the toplevel element 'name' of the input. In the second statement it refers to the "name" element of the "item" selection in the query, e.g. for each element with the path "/item/name" (name beeing unique per item and item describing a set of items).
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/first_example.tdl" parse="text" />
		</programlisting>
		</para>
		</sect3>
		<sect3>
		<title>Preprocessing Input</title>
		<para>The example selects are id's depending on a normalized name. The normalization is done in a preprocessing step
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/preprocess_example.tdl" parse="text" />
		</programlisting>
		</para>
		</sect3>
		<sect3>
		<title>Using Variables</title>
		<para>The example returns the 'id' of a country depending on a normalized name. The normalization is done in a preprocessing step. The result is printed into a structure country/code;
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/variable_example.tdl" parse="text" />
		</programlisting>
		</para>
		</sect3>
		<sect3>
		<title>Subroutines</title>
		<para>The example calls an subroutine with one argument to map the output.
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/operation_example.tdl" parse="text" />
		</programlisting>
		</para>
		</sect3>
	</sect2>
	<sect2>
	<title>Language Description</title>
		<para>
		A TDL program consists of subroutine declarations and exported
		transaction function declarations. Subroutines have the same
		structure as transaction function blocks but without pre- and postprocessing
		and authotization method declarations.
		</para>
		<sect3>
			<title>Subroutines</title>
			<para>A subroutine declaration starts with the Keyword <code>SUBROUTINE</code>
			followed by the subroutine name. After this header and an optional 
			result substructure name declaration, the code definition block
			follows starting with <code>BEGIN</code>, ending with <code>END</code>.
			<programlisting language='sql'>
			SUBROUTINE &lt;name&gt;
			RESULT INTO &lt;result-block-name&gt;
			BEGIN
				...&lt;database or subroutine calls&gt;...
			END
			</programlisting>
			The line with the RESULT INTO declaration is optional.
			</para>
		</sect3>

		<sect3>
			<title>Transaction Function Declarations</title>
			<para>A transaction function declaration starts with the Keyword <code>TRANSACTION</code> followed
			by the transaction function name. This name identifies the function globally.
			The body of the function contains the following parts:
			<itemizedlist>
				<listitem><code>AUTHORIZE ( &lt;auth-function&gt;, &lt;auth-resource&gt; )</code>
					<para>
						This optional definition is dealing with 
						authorization and access rights.
					</para>
				</listitem>
				<listitem><code>RESULT INTO &lt;result-block-name&gt; FILTER &lt;post-filter-name&gt;</code>
					<para>
						This optional declaration defines a top level tag for the 
						result structure and optionally a post processing step as
						filter referenced by name.
						It is similar as the construct in the subroutine description
						except that you cannot specify a postprocessing filter
						in a subroutine.
					</para>
				</listitem>
				<listitem><code>PREPROCESS BEGIN &lt;...preprocessing function calls...&gt; END</code>
					<para>
						This optional block contains function calls on the transaction
						function input. The result of these preprocessing function calls are
						put into the input structure, so that they can be refered to in the main
						code definition block of the transaction.
						You can call any global normalization or form function in the 
						preprocessing block to enrich the input to process.
					</para>
				</listitem>
				<listitem><code>BEGIN &lt;...database or subroutine calls...&gt; END</code>
					<para>
					The main processing block starts with <code>BEGIN</code> and
					ends with <code>END</code>. It contains all the database instructions
					needed for completing this transaction.
					</para>
				</listitem>
			</itemizedlist>
			The following pseudo code snippet shows the explained building
			blocks together:
			<programlisting language='sql'>
	
			TRANSACTION &lt;name&gt;
			AUTHORIZE ( &lt;auth-function&gt;, &lt;auth-resource&gt; )
			RESULT INTO &lt;result-block-name&gt; FILTER &lt;post-filter-name&gt;
			PREPROCESS BEGIN
				...&lt;preprocessing function calls&gt;...
			END
			BEGIN
				...&lt;database or subroutine calls&gt;...
			END
			</programlisting>
			The lines with AUTHORIZE and RESULT INTO and FILTER declarations are optional.
			So is the preprocessing block PREPROCESS..BEGIN..END. A simpler transaction
			function looks like the following:
			<programlisting language='sql'>
	
			TRANSACTION &lt;name&gt;
			BEGIN
				...&lt;database or subroutine calls&gt;...
			END
			</programlisting>
			</para>
		</sect3>
		<sect3>
		<title>Keywords</title>
		<para>
			<simplelist type="horiz" columns="2">
			<member>TRANSACTION</member><member>Defines a block of statements in the following BEGIN ... END block as transaction.</member>
			<member>AUTHORIZE</member><member>Followed by a pair of identifiers in '(' ')' brackets, separated by a comma. Defines the method to call for granting authorization to the caller of this transaction.</member>
			<member>SUBROUTINE</member><member>Defines a block of statements in the following BEGIN ... END block that can be called as single instruction.</member>
			<member>PREPROCESS</member><member>Defines a block of preprocessing statements for processing selected input and writing into the input structure for further processing.</member>
			<member>BEGIN</member><member>Marks the start of an execution block (terminated by END) of a TRANSACTION or SUBROUTINE or PREPROCESS or RESULT INTO block.</member>
			<member>END</member><member>Marks the end of an execution block.</member>
			<member>RESULT</member><member>Defines subsection of the result built. It is followed by a INTO and an identifier defining a relative path in result where the following block marked with BEGIN .. END is mapped to</member>
			<member>FOREACH</member><member>Followed by a selection path. Defines a selection in nodes as input of the associated command. The associated command is executed for each member of the selection. All relative path expressions in the associated command arguments have the path of a selected element of the instruction as base.</member>
			<member>INTO</member><member>Followed by an identifier or a path that declares the result tag for each result element of the associated command</member>
			<member>DO</member><member>Invokes a database command or subroutine call referenced in the argument. DO is followed by an embedded SQL command terminated with ';' or by a subroutine call</member>
			<member>UNIQUE</member><member>constraint on a database command or subroutine call result: Result must be unique, if it exists</member>
			<member>NONEMPTY</member><member>constraint on a database command or subroutine call result: Result must not be empty</member>
			<member>LET</member><member>Starts a variable declaration for the current scope. Variables can refer to single database command or subroutine call results.</member>
			<member>ON ERROR</member><member>Starts a declaration for a hint for a certain error class to enrich error messages with context information of the current instruction</member>
			<member>HINT</member><member>Declares an error message in an ON ERROR &lt;errclass&gt; HINT declaration</member>
			<member>PRINT</member><member>Declares a print of an argument into the result context of the print declaration scope. The argument can be a variable or result reference but cannot refer to input. The print instruction can use an INTO path as well to declare a target path in the result</member>
			</simplelist>
		</para>
		</sect3>
		<sect3>
		<title>Substitutes in Command Arguments</title>
		<para>
			List of Substitutes
			<simplelist type="horiz" columns="3">
			<member>Element</member><member>Example</member><member>Description</member>
			<member>$NNN</member><member>$1</member><member>Column of a row of the last result addressed by index (counted from 1 for the first column). A command containing any result reference is executed for each row of the last result</member>
			<member>$columname</member><member>$id</member><member>Column of a row of last result addressed by name. A command containing any result reference is executed for each row of the last result</member>
			<member>$(path)</member><member>$(person/id)</member><member>Single element addressed by relative path from the current input selection</member>
			<member>$[varname]</member><member>$[id]</member><member>Variable reference refering to a single result or NULL (not a set!) previously in the same scope declared with LET varname = &lt;result column reference&gt;;</member>
			</simplelist>
		</para>
		</sect3>
	</sect2>
</sect1>

