<sect1>
<title>Functions in Transaction Definition Language (TDL)</title>
	<sect2>
		<title>Introduction</title>
		<para>
			For the description of transactions <application>Wolframe</application> provides the
			transaction definition language (<acronym>TDL</acronym>) introduced here.
			<application>Wolframe</application> transactions in <acronym>TDL</acronym> are defined as functions in a
			transactional context. This means that whatever is executed in a transaction function
			belongs by default to a transaction with an auto-commit on function completion
			if not explicitely defined otherwise by the caller.
		</para>
		<para>
			A <acronym>TDL</acronym> transaction function takes a structure as input
			and returns a structure as output.
			The <application>Wolframe</application> database interface defines 
			a transaction as context where input is passed as structure 
			and the output is fetched from as structure.
		</para>
		<para>
			TDL is a programming language to describe the building of transaction 
			input and the building of the result structure from the database output.
			It defines a transaction as a sequence of instructions on multiple data.
			An instruction is either discribed as a single embedded database command
			in the language of the underlaying database, a name of a function declared
			in the database (e.g. a PLSQL function) or a TDL subroutine call
			working on multiple data.
		</para>
		<para>
			Working on multiple data means that the instruction is executed
			for every item of an input set. This set can consist of the set of
			results of a previous instruction or a selection of the
			input of the transaction function. A quantifier that is 
			part of the instruction defines the input set.
		</para>
		<para>
			Each instruction result can be declared as being part of the transaction
			result structure. The language has no control structures and is 
			therefore not a general purpose programming language.
			It just offers some mapping of input to commands and from commands 
			results to output.
		</para>
		<para>
			For input data conversion the transaction definition language 
			defines a preprocessing section where globally defined wolframe
			functions can be called for selected input. For building an output 
			structure that cannot be modeled with a language without control
			structures and recursion TDL provides the possibility to call a
			globally defined function as filter for postprocessing of the
			transaction function result.
		</para>
		<para>
			The TDL is case insensitive. For clearness and better readability
			TDL keywords are written in uppercase here.
		</para>
	</sect2>
	<sect2>
		<title>Examples</title>
		<sect3>
		<title>First</title>
		<para>This example selects a key from a table and uses it for an insert into a list. The substitute "$1" refers to the first column of the "SELECT id FROM UserTable .." query result. The substitute "$(name)" in the first statement refers to the toplevel element 'name' of the input. In the second statement it refers to the "name" element of the "item" selection in the query, e.g. for each element with the path "/item/name" (name beeing unique per item and item describing a set of items).
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/first_example.tdl" parse="text" />
		</programlisting>
		</para>
		</sect3>
		<sect3>
		<title>Preprocessing Input</title>
		<para>The example selects are id's depending on a normalized name. The normalization is done in a preprocessing step
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/preprocess_example.tdl" parse="text" />
		</programlisting>
		</para>
		</sect3>
		<sect3>
		<title>Using Variables</title>
		<para>The example returns the 'id' of a country depending on a normalized name. The normalization is done in a preprocessing step. The result is printed into a structure country/code;
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/variable_example.tdl" parse="text" />
		</programlisting>
		</para>
		</sect3>
		<sect3>
		<title>Subroutines</title>
		<para>The example calls an subroutine with one argument to map the output.
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/operation_example.tdl" parse="text" />
		</programlisting>
		</para>
		</sect3>
	</sect2>
	<sect2>
	<title>Language Description</title>
		<para>
		A TDL program consists of subroutine declarations and exported
		transaction function declarations. Subroutines have the same
		structure as transaction function blocks but without pre- and postprocessing
		and authotization method declarations.
		</para>
		<sect3>
			<title>Subroutines</title>
			<para>A subroutine declaration starts with the Keyword <code>SUBROUTINE</code>
			followed by the subroutine name. After this header and an optional 
			result substructure name declaration, the code definition block
			follows starting with <code>BEGIN</code>, ending with <code>END</code>.
			<programlisting language='sql'>
			SUBROUTINE &lt;name&gt;
			RESULT INTO &lt;result-block-name&gt;
			BEGIN
				...&lt;instructions&gt;...
			END
			</programlisting>
			The line with the RESULT INTO declaration is optional.
			</para>
		</sect3>

		<sect3>
			<title>Transaction Function Declarations</title>
			<para>A transaction function declaration starts with the Keyword <code>TRANSACTION</code>
			followed by the transaction function name. This name identifies the
			function globally. The body of the function contains the following parts:
			<itemizedlist>
				<listitem><code>AUTHORIZE ( &lt;auth-function&gt;, &lt;auth-resource&gt; )</code>
					<para>
						This optional definition is dealing with 
						authorization and access rights.
					</para>
				</listitem>
				<listitem><code>RESULT INTO &lt;result-block-name&gt; FILTER &lt;post-filter-name&gt;</code>
					<para>
						This optional declaration defines a top level tag for the 
						result structure and optionally a post processing step as
						filter referenced by name.
						It is similar as the construct in the subroutine description
						except that one cannot specify a postprocessing filter
						in a subroutine.
					</para>
				</listitem>
				<listitem><code>PREPROCESS BEGIN &lt;...preprocessing instructions...&gt; END</code>
					<para>
						This optional block contains instructions on the transaction
						function input. The result of these preprocessing instructions are
						put into the input structure, so that they can be refered to in the main
						code definition block of the transaction.
						We can call any global normalization or form function in the 
						preprocessing block to enrich or transform the input to process.
					</para>
				</listitem>
				<listitem><code>BEGIN &lt;...instructions...&gt; END</code>
					<para>
					The main processing block starts with <code>BEGIN</code> and
					ends with <code>END</code>. It contains all the database instructions
					needed for completing this transaction.
					</para>
				</listitem>
			</itemizedlist>
			The following pseudo code snippet shows the explained building
			blocks together:
			<programlisting language='sql'>
	
			TRANSACTION &lt;name&gt;
			AUTHORIZE ( &lt;auth-function&gt;, &lt;auth-resource&gt; )
			RESULT INTO &lt;result-block-name&gt; FILTER &lt;post-filter-name&gt;
			PREPROCESS BEGIN
				...&lt;preprocessing instructions&gt;...
			END
			BEGIN
				...&lt;instructions&gt;...
			END
			</programlisting>
			The lines with AUTHORIZE and RESULT INTO and FILTER declarations are optional.
			So is the preprocessing block PREPROCESS..BEGIN..END. A simpler transaction
			function looks like the following:
			<programlisting language='sql'>
	
			TRANSACTION &lt;name&gt;
			BEGIN
				...&lt;instructions&gt;...
			END
			</programlisting>
			</para>
		</sect3>
		<sect3>
			<title>Main Processing Instructions</title>
			<para>Main processing instructions defined in the main execution block 
			of a subroutine or transaction function consist of three parts in the
			following order:
			<itemizedlist>
				<listitem><code>INTO &lt;result substructure name&gt;</code>
					<para>
						This optional directive specifies if and where the results
						of the database commands should be put into as part of the
						function output. In operations this substructure is one
						relative to the current substructure addressed.
						A subroutine with an "INTO myres"
						directive called by a subroutine with an "INTO output"
						directive will write its result into substructure
						"output/myres".
					</para>
				</listitem>
				<listitem><code>FOREACH &lt;selector&gt;</code>
					<para>
						This optional directive specifies a quantifier
						defining the set of elements on which the 
						instruction is executed one by one. Specifying
						a set of two elements will cause the function to
						be called twice. An empty set as quantifier will
						cause the instruction to be ignored. Without
						quantifier the database command or subroutine call
						of the instrucution will be always be executed once.
					</para>
					<para>
						The argument of the FOREACH quantifier is either
						a reference to the result of a previous 
						instruction or a path selecting a set of input
						elements.
					</para>
					<para>
						Results of previous instructions are referenced either with
						the keyword RESULT refering to the result set
						of the previous command or with a variable
						naming a result set declared with this name before.
						
					</para>
						Input elements are selected by path relatively
						from the current path selected starting from
						the input root element when entering a transaction
						function. The current path selected and the base
						element of any relative path calculated in this scope
						changes when a subroutine is called in in a FOREACH selection
						context. Calling for example a subroutine in a
						'FOREACH person' quantifier context will cause
						relative paths in this subroutine to be subelements
						of 'person'.
					<para>
					</para>
				</listitem>
				<listitem><code>DO &lt;command&gt;</code>
					<para>
						Commands in an instruction are either embedded
						database commands, named database functions (e.g. PLSQL functions)
						or subroutine calls. Command arguments
						are either constants or relative paths 
						from the selector path in the FOREACH quantifier 
						or refering to elements in the result of 
						a previous command.
						If an argument is a relative path from the 
						selector context, its reference
						has to be unique in the context of the 
						element selected by the selector.
						If an argument references a previous command
						result it must either be unique or dependent
						an the quantifier argument. 
						Results that are sets with more than one element
						can only be referenced if they are bound to 
						the FOREACH quantifier.
					</para>
				</listitem>
			</itemizedlist>
			</para>
		</sect3>
		<sect3>
		<title>Preprocessing Instructions</title>
		<para>Preprocessing instructions defined in the PREPROCESS execution block 
			of a transaction function consist similar to the instructions
			in the main execution block of three parts in the
			following order:
		<itemizedlist>
			<listitem><code>INTO &lt;result substructure name&gt;</code>
				<para>
					This optional directive specifies if and where the results
					of the preprocessing commands should be put into as part
					of the input to be processed by the main processing
					instructions. The relative paths of the destination structure
					are calculated relatively to the FOREACH quantifier.
				</para>
			</listitem>
			<listitem><code>FOREACH &lt;selector&gt;</code>
				<para>
					This optional directive specifies a quantifier
					defining the set of elements on which the 
					instruction is executed one by one.
					The argument of the FOREACH quantifier defines the number of
					calls of the command specified as the cardinality
					of the set selected. The preprocessing command is
					executed once for each element in the selected set
					and it will not be executed if the selected
					set is empty.
				</para>
				<para>
					The argument of the FOREACH quantifier is
					a path selecting a set of input elements.
				</para>
			</listitem>
			<listitem><code>DO &lt;command&gt;</code>
				<para>
					Commands in an instruction are function calls of
					globally defined form functions or normalization
					functions. Command arguments
					are constants or relative paths from the selector
					path in the FOREACH quantifier referencing unique
					elements in the context of a quantifier element
					selected.
				</para>
			</listitem>
		</itemizedlist>
		</para>
		</sect3>
		<sect3>
		<title>Keywords</title>
		<para>
			<simplelist type="horiz" columns="2">
			<member>TRANSACTION</member><member>Defines a block of statements in the following BEGIN ... END block as transaction.</member>
			<member>AUTHORIZE</member><member>Followed by a pair of identifiers in '(' ')' brackets, separated by a comma. Defines the method to call for granting authorization to the caller of this transaction.</member>
			<member>SUBROUTINE</member><member>Defines a block of statements in the following BEGIN ... END block that can be called as single instruction.</member>
			<member>PREPROCESS</member><member>Defines a block of preprocessing statements for processing selected input and writing into the input structure for further processing.</member>
			<member>BEGIN</member><member>Marks the start of an execution block (terminated by END) of a TRANSACTION or SUBROUTINE or PREPROCESS or RESULT INTO block.</member>
			<member>END</member><member>Marks the end of an execution block.</member>
			<member>RESULT</member><member>Defines subsection of the result built. It is followed by a INTO and an identifier defining a relative path in result where the following block marked with BEGIN .. END is mapped to</member>
			<member>FOREACH</member><member>Followed by a selection path. Defines a selection in nodes as input of the associated command. The associated command is executed for each member of the selection. All relative path expressions in the associated command arguments have the path of a selected element of the instruction as base.</member>
			<member>INTO</member><member>Followed by an identifier or a path that declares the result tag for each result element of the associated command</member>
			<member>DO</member><member>Invokes a database command or subroutine call referenced in the argument. DO is followed by an embedded SQL command terminated with ';' or by a subroutine call</member>
			<member>UNIQUE</member><member>constraint on a database command or subroutine call result: Result must be unique, if it exists</member>
			<member>NONEMPTY</member><member>constraint on a database command or subroutine call result: Result must not be empty</member>
			<member>LET</member><member>Starts a variable declaration for the current scope. Variables can refer to single database command or subroutine call results.</member>
			<member>ON ERROR</member><member>Starts a declaration for a hint for a certain error class to enrich error messages with context information of the current instruction</member>
			<member>HINT</member><member>Declares an error message in an ON ERROR &lt;errclass&gt; HINT declaration</member>
			<member>PRINT</member><member>Declares a print of an argument into the result context of the print declaration scope. The argument can be a variable or result reference but cannot refer to input. The print instruction can use an INTO path as well to declare a target path in the result</member>
			</simplelist>
		</para>
		</sect3>
		<sect3>
		<title>Substitutes in Command Arguments</title>
		<para>
			List of Substitutes
			<simplelist type="horiz" columns="3">
			<member>Element</member><member>Example</member><member>Description</member>
			<member>$NNN</member><member>$1</member><member>Column of a row of the last result addressed by index (counted from 1 for the first column). A command containing any result reference is executed for each row of the last result</member>
			<member>$columname</member><member>$id</member><member>Column of a row of last result addressed by name. A command containing any result reference is executed for each row of the last result</member>
			<member>$(path)</member><member>$(person/id)</member><member>Single element addressed by relative path from the current input selection</member>
			<member>$[varname]</member><member>$[id]</member><member>Variable reference refering to a single result or NULL (not a set!) previously in the same scope declared with LET varname = &lt;result column reference&gt;;</member>
			</simplelist>
		</para>
		</sect3>
	</sect2>
</sect1>

