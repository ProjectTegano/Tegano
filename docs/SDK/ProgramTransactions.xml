<sect1>
<title>Database Transaction Functions</title>
	<sect2>
		<title>Introduction</title>
		<para>
			For the description of transactions <code>Wolframe</code> provides the
			transaction definition language (TDL) introduced here.
			<code>Wolframe</code> transactions in TDL are defined as functions in a transactional context.
			This means that whatever is executed in a transaction function belongs by default to 
			a transaction with an auto-commit on function completion if not explicitely defined otherwise 
			by the caller.
		</para>
		<para>
			A TDL transaction function takes a structure as input and returns a structure as output.
			The <code>Wolframe</code> database interface defines a transaction as context where input is passed as structure and the output is fetched from as structure.
			The TDL is a programming language to describe the building of transaction input and the building of the result structure from the database output.
			It defines a transaction as a sequence of database operations. A database operation is either a single embedded database instruction in the language of the underlaying database, a name of a procedure declared in the database or a block of operations delared with OPERATION. It adds some constructs to address input structure elements or database command results as arguments.
			Each database command result can be declared as being part of the transaction result structure.
			The language has no control structures and is therefore not a general purpose programming language.
			It just offers some mapping of input to commands and from commands results to output.
		</para>
		<para>
			For input data conversion the transaction definition language lets you define a
			preprocessing section where wolframe functions defined can be called for selected input.
		</para>
		<para>
			The TDL is case insensitive. For clearness and better readability TDL keywords are written in uppercase here.
		</para>
	</sect2>
	<sect2>
		<title>First example</title>
		<para>This example selects a key from a table and uses it for an insert into a list. The substitute "$1" refers to the first column of the "SELECT id FROM UserTable .." query result. The substitute "$(name)" in the first statement refers to the toplevel element 'name' of the input. In the second statement it refers to the "name" element of the "item" selection in the query, e.g. for each element with the path "/item/name" (name beeing unique per item and item describing a set of items).
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/first_example.tdl" parse="text" />
		</programlisting>
		</para>
	</sect2>
	<sect2>
		<title>Example with pre-processing input</title>
		<para>The example selects are id's depending on a normalized name. The normalization is done in a preprocessing step
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/preprocess_example.tdl" parse="text" />
		</programlisting>
		</para>
	</sect2>
	<sect2>
		<title>Example with pre-processing input and using variables in database commands</title>
		<para>The example returns the 'id' of a country depending on a normalized name. The normalization is done in a preprocessing step. The result is printed into a structure country/code;
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/variable_example.tdl" parse="text" />
		</programlisting>
		</para>
	</sect2>
	<sect2>
		<title>Example calling operations</title>
		<para>The example calls an operation with one argument to map the output.
		<programlisting language='sql'>
		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/SDKTutorial/operation_example.tdl" parse="text" />
		</programlisting>
		</para>
	</sect2>
	<sect2>
		<title>Description of keywords</title>
		<para>
			<simplelist type="horiz" columns="2">
			<member>TRANSACTION</member><member>Defines a block of statements in the following BEGIN ... END block as transaction.</member>
			<member>AUTHORIZE</member><member>Followed by a pair of identifiers in '(' ')' brackets, separated by a comma. Defines the method to call for granting authorization to the caller of this transaction.</member>
			<member>OPERATION</member><member>Defines a block of statements in the following BEGIN ... END block as single operation.</member>
			<member>PREPROCESS</member><member>Defines a block of preprocessing statements for processing selected input and writing into the input structure for further processing.</member>
			<member>BEGIN</member><member>Marks the start of an execution block (terminated by END) of a TRANSACTION or OPERATION or PREPROCESS or RESULT INTO block.</member>
			<member>END</member><member>Marks the end of an execution block.</member>
			<member>RESULT</member><member>Defines subsection of the result built. It is followed by a INTO and an identifier defining a relative path in result where the following block marked with BEGIN .. END is mapped to</member>
			<member>FOREACH</member><member>Followed by a selection path. Defines a selection in nodes as input of the associated command. The associated command is executed for each member of the selection. All relative path expressions in the associated command arguments have the path of a selected element of the operation as base.</member>
			<member>INTO</member><member>Followed by an identifier or a path that declares the result tag for each result element of the associated command</member>
			<member>DO</member><member>Starts a database command or execute operation declaration. It is followed by an embedded SQL command terminated with ';' or by an operation call</member>
			<member>UNIQUE</member><member>constraint on a database command or operation result: Result must be unique, if it exists</member>
			<member>NONEMPTY</member><member>constraint on a database command result: Result must not be empty</member>
			<member>LET</member><member>Starts a variable declaration for the current scope. Variables can refer to single database command results.</member>
			<member>ON ERROR</member><member>Starts a declaration for a hint for a certain error class to enrich error messages with context information of the current operation</member>
			<member>HINT</member><member>Declares an error message in an ON ERROR &lt;errclass&gt; HINT declaration</member>
			<member>PRINT</member><member>Declares a print of an argument into the result context of the print declaration scope. The argument can be a variable or result reference but cannot refer to input. The print instruction can use an INTO path as well to declare a target path in the result</member>
			</simplelist>
		</para>
	</sect2>
	<sect2>
		<title>Substitutes in database commands and argument lists of operations</title>
		<para>
			List of Substitutes
			<simplelist type="horiz" columns="3">
			<member>Element</member><member>Example</member><member>Description</member>
			<member>$NNN</member><member>$1</member><member>Column of a row of the last result addressed by index (counted from 1 for the first column). A command containing any result reference is executed for each row of the last result</member>
			<member>$columname</member><member>$id</member><member>Column of a row of last result addressed by name. A command containing any result reference is executed for each row of the last result</member>
			<member>$(path)</member><member>$(person/id)</member><member>Single element addressed by relative path from the current input selection</member>
			<member>$[varname]</member><member>$[id]</member><member>Variable reference refering to a single result or NULL (not a set!) previously in the same scope declared with LET varname = &lt;result column reference&gt;;</member>
			</simplelist>
		</para>
	</sect2>
</sect1>

