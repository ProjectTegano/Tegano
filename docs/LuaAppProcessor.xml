<!-- Lua Application Processor -->
<chapter>
	<title>Implementing Wolframe Applications With Lua</title>

	<sect1>
		<title>Introduction</title>
		<para>
		You can write applications in <code>Wolframe</code> with <code>Lua</code>. A tutorial for the use of 
		<code>Lua</code> is not provided here.
		For an introduction into programming with <code>Lua</code> see http://www.lua.org. The official manual also
		available as book is very good. <code>Wolframe</code> introduces some <code>Lua</code> interface to access
		input, output and database. The <code>Lua</code> application layer doesn't deal with protocol or
		encryption issues. The application layer gets just an iterator over the input content to process,
		an output stream interface for data content to return to the client, an interface to store and retrieve data
		from databases and access to other devices. In the following section we describe this interfaces.
		</para>

		<title>Interfaces</title>
		<sect2>
			<title>Filters</title>
			<para>
			The application input and output can be of different form. This depends on the kind
			of application and the kind of client accessing the service. For different forms
			of input and output <code>Wolframe</code> provides you filters. Filters are <code>Lua</code>
			objects without visible properties for the application. The system provides a global function
			<code>
			 filter( )
			</code>
			with the name of the filter as string as parameter. If you for example want to process
			data as XML in the character set encoding UTF-8 you need to get a filter by calling
			<code>
			 filter( "XML:UTF-8" )
			</code>
			The object returned by this function can be attached to input or output. You can have
			different filters for input and output, but only one at a time. But you can switch the filter
			during processing. You even have to do so for processing XML. The XML header is in ASCII
			and the body is in the character set encoding defined in the header. So you process the
			header with one filter. After the header is processed you attach another filter to
			input and maybe to output too, depending on the XML header attributes.
			</para>
			<title>Input</title>
			<para>
			Input is a accessed over a global variable input. This object has the following methods:
			<code>
			 input:as( f )
			</code>
			attaches a filter f to the input. Subsequent calls of <code>input:get()</code> will apply this
			filter f to get the input elements to process.
			<code>
			 input:get( )
			 </code>
			returns a function with closure to iterate over the input. The returned function returns one
			or two values depending on the filter. Unstructured input returns one value, the input element.
			Structured input returns the element content as first value and the attribute or tag as second
			value. If one of them is not available, then a boolean <code>false</code> is retured in its place.
			An XML tag for example is returned as <code>false</code>;tagname. An attribute, value pair
			is returned as value;name. A content element is returned as value;<code>false</code> or
			value;<code>nil</code>, depending on the filter type.
			A close tag is returned as a pair of boolean <code>false</code> values
			(<code>false</code>;<code>false</code>).
			The reason for using <code>false</code>, instead of <code>nil</code>, is the special treatment
			of <code>nil</code> in a <code>Lua</code> for loop. <code>nil</code> is always terminating the
			iteration, no matter what follows this <code>nil</code>. <code>nil</code> is returned at the
			end of the data or, if the iteration started in a subsection of the content, as the last tag of
			context the iteration has started closes. The later construct is used when you delegate the
			content processing of subsections.
			</para>
			<title>Output</title>
			<para>
			Output is a accessed over a global variable output. This object has the following methods:
			<code>
			 output:as( f )
			 </code>
			attaches a filter f to the output. Subsequent calls of <code>print()</code> will apply this 
			filter f to print the output elements returned as content to the client.
			 <code>
			 output:print( c, t)
			 output:print( c)
			 </code>
			prints an element to the output. Omitting t, means that an untagged content element is printed. 
			The same happens when you call print with nil or <code>false</code> as second parameter t. 
			With c passed as <code>nil</code> or <code>false</code> you print a open tag or close tag, 
			depending on t. t is a tag name for open tag and <code>nil</code> or <code>false</code> for
			a close previous tag. With c,t as non <code>nil</code> or <code>false</code> values you print
			an attribute value assignement.
			</para>
		</sect2>
		<title>Examples</title>
		<sect2>		
			<title>Example 1: An echo processor</title>
			<para>This example echoes the input line by line. It uses the default filter that is a line 
				iterator for text in the default character set encoding.</para>
			<code>
			 function run_example1( )
			 	for c in input:get() do
		 			output:print( c)
		 		end
			 end
			</code>
			<title>Example 2: An echo processor for well formed tagged content</title>
			<para>This example processes well formed tagged content, an XML without a header in a 
				predefined encoding. </para>
			<code>
			 function run_example2( )
			 	input:as( filter( "XML:Isolatin"))
			 	output:as( filter( "XML:Isolatin"))
			 	for c,t in input:get() do
			 		output:print( c, t)
			 	end
			 end
			<code>
			<title>Example 3: An XML echo processor</title>
			<para>This example procedure will extract the character set encoding from the XML header an 
				echo the document in the same encoding. If the encoding is not specified, then it 
				will assumed to be UTF-8.</para>
			<code>
			 function run_example3( )
			 	input:as( filter( "XML:Header"))
			 	f = filter( "XML:UTF-8")
			 	for c,t in input:get() do
			 		if t == "charset" then
 						f = filter( "XML:" + c )
			 		end
			 		output:print( c, t)
			 	end
			 	input:as( f)
			 	for c,t in input:get() do
			 		output:print( c, t)
			 	end
			 end
			</code>
			<title>Example 4: An XML echo processor</title>
			<para>This example does the same as example3 but treats the content of the tag "content" in an 
				own procedure. </para>
			<code>
			 function process_content( itr)
			 	for c in itr do
			 		output:print( c)
			 	end
			 end 

			 function run_example4( )
			 	input:as( filter( "XML:Header"))
			 	f = filter( "XML:UTF-8")
			 	for c,t in input:get() do
			 		if t == "charset" then
			 			f = filter( "XML:" + c )
			 		end
			 		output:print( c, t)
			 	end
			 	input:as( f)
			 	for c,t in input:get() do
			 		output:print( c, t)
			 		if t = "content" then
			 			process_content( input:get())
			 			output:print( false, false)
			 		end
			 	end
			 end
			</code>
			<title>Example 5: Load XML into a table</title>
			<para>This example procedure load the content of the XML document into a global table under 
				the unverified (!) assumption that every element appears only once.</para>
			<code>
			 function load_table( itr)
				rt = {}
			 	i = 0
			 	function idx()
			 		i = i + 1
			 		return i
			 	end
			 	for c,t in itr do
			 		rt[ t or idx() ] = c or load_table( itr )
			 	end
			 end
			 inputtable = {}
			 function run_example5( )
			 	input:as( filter( "XML:Header"))
			 	f = filter( "XML:UTF-8")
			 	for c,t in input:get() do
			 		if t == "charset" then
			 			f = filter( "XML:" + c )
			 		end
			 		output:print( c, t)
			 	end
			 	input:as( f)
			 	inputtable = load_table( input:get())
			 end
			</code>
			<title>Example 6: Using the database</title>
		</sect2>
		<sect2>
			<title>Motivation</title>
			<para>The parameters of the output instruction correspond to the input iterators return values. 
				The parameters have the same order and the same meaning. The input and output operations 
				look not very intuitive. But it is easy to create a table as shown in example 5.
			</para>
		</sect2>
	</sect1>
</chapter>
