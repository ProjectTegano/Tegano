<!-- step 4 -->

<sect1>
	<title>Step 4 - Implement server side customer list</title>	

	<para>
		We want to store the customer data in a Sqlite database, so we have to
		tell the server to load the database module for Sqlite:
		<programlisting language='shell'>
	LoadModules {
		module mod_db_sqlite3
	}
		</programlisting>
	</para>
	
	<para>
		Now we also have to create a database and populate it with the
		following schema:

		<programlisting language='shell'>
	CREATE TABLE Customer (
		id              INTEGER PRIMARY KEY AUTOINCREMENT,
		name            TEXT    NOT NULL,
		address         TEXT
	);
		</programlisting>
	</para>
	
	<para>
		Store this into <filename>schema.sql</filename>. Then execute:

		<programlisting language='shell'>
	sqlite3 tutorial.db &lt; schema.sql
		</programlisting>
	</para>

	<para>
		Now we have to tell server to use this sqlite database file:

		<programlisting language='shell'>
	database {
		SQLite {
			identifier	sqlitedb
			file		tutorial.db
			foreignKeys	yes
		}
	}
		</programlisting>
	
	</para>
	
	<para>
		When we restart the server we see:

		<programlisting language='shell'>
	DEBUG: SQLite database unit 'sqlitedb' created with 3 connections to file 'tutorial.db'
		</programlisting>
	</para>
	
	<para>
		Now we want to use some XML filters to send/receive XML over the protocol,
		so we have to add the following module to tutorial.conf:

		<programlisting language='shell'>
	LoadModules {
		..
		module mod_filter_libxml2
		..
	}
		</programlisting>
	</para>

	<para>
		In order to see which modules are currently loaded in the wolframed we can
		use:

		<programlisting language='shell'>
	/usr/sbin/wolframed -p -c tutorial.conf
		</programlisting>
	</para>

	<para>
		We see:

		<programlisting language='shell'>
	..
	Module files to load:
 	  /usr/lib/wolframe/modules/mod_db_sqlite3
	  /usr/lib/wolframe/modules/mod_filter_libxml2
	..
		</programlisting>
		which looks ok.
	</para>
	
	<para>
		For mapping the requests to programs we need the directmap module. First
		add to <filename>tutorial.conf</filename>:

		<programlisting language='shell'>
	LoadModules {
		..
		module mod_command_directmap
		..
	}
		</programlisting>
		and 
		<programlisting language='shell'>
	Processor {
		database sqlitedb
		cmdhandler {
			directmap {
				filter libxml2
				program tutorial.dmap
			}
		}
	}
		</programlisting>
	</para>

	<para>
		The "filter" directive denotes that the command handler should
		use the "libxml2" module to parse XML requests.
	</para>
	
	<para>
		Now we have to create a file <filename>tutorial.dmap</filename>.
		This file maps the requests to the corresponding transaction definitions:

		<programlisting language='shell'>
	COMMAND CustomerListRequest CALL SelectCustomerList RETURN STANDALONE list;
		</programlisting>

		This means that we map the 'CustomerListRequest' request to a function 'SelectCustomerList'
		that is executed to perform the request. It will returns us document 
		without a document type assigned (standalone) and with the root element 'list'. 
		The returned content will be a list of customers. The function will be implemented 
		in a TDL program in the server. We first add the
		TDL program declaration to the processor configuration section:

		<programlisting language='shell'>
	Processor {
		program Customer.tdl
	}
		</programlisting>

		The <filename>Customer.tdl</filename> file contains the database transaction we want to execute.
		We also specify that we want the result to be a 'list' which contains
		'customer' tags with the data per customer:

		<programlisting language='shell'>
	TRANSACTION SelectCustomerList
	BEGIN
		INTO customer DO SELECT * from Customer;
	END
		</programlisting>

	We also need a validator for the input when the client sends a 'CustomerListRequest'.
	we install the simple form DDL compilter in <filename>tutorial.conf</filename> and
	register the simpleform program to the list of programs:

		<programlisting language='shell'>
	LoadModules {
		..
		module mod_ddlcompiler_simpleform
	}

	Processor {
		..
		program Customer.sfrm	
		..
	}
		</programlisting>

	and we add a simple form file <filename>Customer.sfrm</filename>.
	We add a form called 'CustomerListRequest' which is empty for now 
	but for the root element 'customer':

		<programlisting language='shell'>
	FORM CustomerListRequest
	{
		customer {
		}
	}
		</programlisting>
	</para>
	
	<para>
		The server shows now a message about the transaction function it
		loaded:
		
		<programlisting language='shell'>
	DEBUG: Loaded transaction function 'SelectCustomerList'
		</programlisting>
	</para>

	<para>
		Now we create a telnet request which contains pseudo authentication credentials 
		and a request for the list of customers, called
		<filename>~/tutorial/client/CustomerListRequest.netcat</filename>:

		<programlisting language='xml'>
<xi:include  xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/Tutorial/CustomerListRequest.netcat" parse="text" />
		</programlisting>

		This we can execute with:

		<programlisting language='shell'>
	netcat -v --wait=2 localhost 7661 &lt; CustomerListRequest.netcat
		</programlisting>

		and we get:

		<programlisting language='xml'>
<xi:include  xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/Tutorial/CustomerListAnswer.netcat" parse="text" />
		</programlisting>
	</para>
	
	<para>
		We got an empty list of customers. So we have successfully configured
		the server for our first command.
	</para>
	
	<para>
		Let's add some customer data now:

		<programlisting language='shell'>
	cat > data.sql
	insert into customer(name,address) values('Dr Who','Blue Police Box');
	insert into customer(name,address) values('John Smith','The Wheel in Space');
	Ctrl-D

	sqlite3 tutorial.db &lt; data.sql
		</programlisting>
	</para>

	<para>
		When we reexecute the netcat command we see that the answer contains now
		the list of customers:

		<programlisting language='xml'>
<xi:include  xmlns:xi="http://www.w3.org/2001/XInclude" href="examples/Tutorial/CustomerList.xml" parse="text" />
		</programlisting>

		So, the data is now correctly retrieved from the database.
	</para>
		
	<para>
		We can move now to the wolfclient to make our first request visible.

	</para>
</sect1>
