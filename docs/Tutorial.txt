Step 6 - Show Customer
------

As next step we want to show how data is communicated between the forms
by implementing a simple "show me customer data" use case.

Let's start by adding a button in 'customers.ui' called 'Show':

(file:step6_customers_edit_button.png)

We add dynamic properties, one is the 'form' which we set to 'customer_show'.

We also add some signals for the double click on the customer list to
click the "Show" button:

(file:step6_customers_signals.png)

We want the currently selected customer to be accessible in the customer_show.ui
form, so we have to remember the current selection of the QTreeWidget named 'customer'
as global variable 'id'. We add a dynamic property with the name 'global.id' and
the value '{customer.id}':

(file:step6_customers_edit_button_props.png)

Now of course we have to create a new form called 'customer_show.ui'. We
choose a form layout and add two fields with labels 'Name:' and 'Address:'
and each of them having a QLineEdit widget. The names of the widgets
should be 'name' and 'address' in order to match the future read request
from the server. Temporarily we also add an 'id' field which shows us
the current value of 'global.id':

(file:step6_customer_show_id.png)

Finally we also need a button which brings us back to the customer list
by simply adding a 'form' action with the value 'customers':

(file:step6_customer_show_back_button.png)

If we start the qtclient and select a customer and press 'Show' we will
notice that the whole "Show Customer" form is empty, even the id. What's
wrong? Well, the widgets in qtclient have the default behaviour of using
'id' attributes attached to the colums of a list for instance. We must
make sure, the server is mapping us the XML correctly with 'id' attribute
and not 'id' as element.

This is the moment we go back to the server and start output form validation.
We add a 'CustomerList.simpleform' form which describes the result of the 'CustomerListRequest'
more precise and especially declares the 'id' as mandatory attribute of the customer:

FORM CustomerList
{
	list
	{
		customer []
		{
			id !@int
			name string
			address string
		}
	}
}

We have to declare output form validation in the 'CustomerListRequest'
in 'tutorial.directmap' as well:

CustomerListRequest = SelectCustomerList( xml ) : CustomerList;

and we have to include the program in 'tutorial.conf' of the server:

Processor {
	..
	program CustomerList.simpleform	
	..
}

Checking with:

netcat -v --wait=2 127.0.0.1 7661 < CustomerListRequest.netcat

we get now:

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE list SYSTEM "CustomerList.simpleform">
<list>
  <customer id="1">
    <name>Dr Who</name>
    <address>Blue Police Box</address>
  </customer>
  <customer id="2">
    <name>John Smith</name>
    <address>The Wheel in Space</address>
  </customer>
</list>

So, that looks ok.

Now also the qtlient shows the id of the customer, when the user double
clicks the customer in the list.

The 'name' and the 'address' fields are still empty. We could of course
use global variables again to propagate the values between forms, but
if the form gets more complex, this is not a good idea.

We start to use the 'initAction' property on the 'customer_show.ui' form
as follows: we want it to execute a read with a document type 'CustomerRequest'
which searches for a single customer by customer id:

(file:step6_customer_show_initaction.png)

We see, that we use the value of 'global.id' again and add it to the 'initAction'
request as attribute 'id' (we can use the qtclient with -d to see the communication
on the wire):

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE customer SYSTEM 'CustomerRequest'>
<customer id="2"/>

We also get in the client:

CRITICAL: ERROR: error in network data loader "Protocol error in command REQUEST, received:  no command handler for 'CustomerRequest'." 

and in the server:

ERROR: error redirect input: no command handler for 'CustomerRequest'

We see, that the request is sent to the server, but we didn't define the
necessary things in the server yet. So we add another map:

CustomerRequest = SelectCustomer( xml ) : Customer;

to 'tutorial.directmap'.

We define a new file 'CustomerRequest.simpleform' which contains the
validation of the customer request (for now, this looks exactly like
the request for the list of customers, but we may want to change that
later):

FORM CustomerRequest
{
	customer {
		id ?@string
	}
}

We register the form in 'tutorial.conf':

Processor {
	..
	program CustomerRequest.simpleform
	..
}

And of course we have to define a transaction function 'SelectCustomer'
in 'Customer.tdl':

TRANSACTION SelectCustomer
RESULT INTO customer
BEGIN
	INTO . DO SELECT * from Customer WHERE id=$(customer/id);
END

The '$(customer/id)' refers to the ID we pass down for the customer record
to retrieve. The 'RESULT INTO customer' makes sure the result will again
be in a table with 'customer' as root element.

We also have to define how the result should be mapped, so:

Processor {
	..
	program Customer.simpleform
	..
}

and 'Customer.sumpleform':

FORM Customer
{
	customer
	{
		id !@string
		name string
		address string
	}
}

Now if we restart client and server and we click on the second
customer in the list we get:

(file:step6_customer_show_working.png)

So we successfully read the data of a customer into a form.

Step 7 - Editing customer
------

We change the show customer use case slightly, so that we can also
edit the customer in the customer_show.ui form.

Let's first make a copy of 'customer_show.ui' and name it 'customer_edit.ui'.

As before we add first a "Edit" button to the 'customers.ui' with 'forms'
set to 'customer_edit' and 'global.id' set to '{customer.id}':

(file:step7_customers_edit_button.png)

We change the form 'customer_edit.ui' and remove the line with 'ID' as we
don't need it anymore and because nobody should be able to edit the id of
a customer and change it! We also add another button and label it 'Save',
this button get the properties 'form' set to 'customers', 'action' set to
'update', 'doctype' to 'CustomerUpdate', 'rootelement' to 'customer' and
'id' to '{global.id}':

(file:step7_customer_edit.png)

The other fields will be sent along automatically in the 'CustomerUpdate' XML request:

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE customer SYSTEM 'CustomerUpdate'>
<customer id="2">
  <name>John Smith</name>
  <address>The Wheel in Space</address>
</customer>

Similar to to the "show customer" case we add now a new map:

editCustomerUpdate = UpdateCustomer( xml );

We also add a simple form 'CustomerUpdate.simpleform' which looks very similar
to the 'Customer.simpleform':

FORM CustomerUpdate
{
	customer
	{
		id !@string
		name string
		address string
	}
}

add it to 'tutorial.conf':

Processor {
	...
	program CustomerUpdate.simpleform
	...
}

finally we write the transaction function 'CustomerUpdate' in 'Customer.tdl':

TRANSACTION UpdateCustomer
BEGIN
	DO UPDATE Customer SET name=$(customer/name), address=$(customer/address)
		WHERE id=$(customer/id);
END

Note, that this time the database transaction doesn't return a result.

Restart server and client and start to edit the customers.

Step 8 - Add a new customer
------

We also want to add new customers to the list. The "add customer" case
is very similar to the "edit customer" case.

Let's copy the 'customer_edit.ui' to 'customer_add.ui'. We remove the
'initAction' and the other dynamic properties from the form itself as
we don't want to read anything when creating a new customer. But of course
we could execute here a "Get new customer initial data" request too which
initializes certain values.

We change the "Save" button and rename it to "Add". We also change the
documenttype there from "CustomerUpdate" to 'CustomerCreate' and we remove
the 'id' property (as this one is automatically choosen by the sequence
in the database). We also have to chaqnge the 'action' from 'update' to
'create':

(file:step8_customer_add.png)

We also introduce a new element here, the 'initalFocus' property. We
set it on the 'name' QLineWidget, so that it gets the initial keyboard
focus when the form is loaded:

(file:step8_customer_add_name_initial_focus.png)

In the 'customers.ui' form we have to add a 'Add' button which has one
property 'form' with value 'customer_add':

(file:step8_customers_add_button.png)

Now for the server side. We add a new mapping for customer creation
in 'tutorial.directmap':

editCustomerUpdate = UpdateCustomer( xml );
createCustomerCreate = CreateCustomer( xml );

We also have to add the simple form 'CustomerCreate.simpleform':

FORM CustomerCreate
{
	customer
	{
		name string
		address string
	}
}

This is the same as 'CustomerUpdate.simpleform' with the exception that
we don't accept an 'id' attribute to be passed to the server.

We register this form in 'tutorial.conf':

Processor {
	..
	program CustomerCreate.simpleform
	..
}

Last we add a 'CreateCustomer' transaction function:

TRANSACTION CreateCustomer
BEGIN
	DO INSERT INTO Customer( name, address )
		VALUES( $(customer/name), $(customer/address) );
END

When we restart the server and client we see the following request
being passed to the wolframe server:

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE customer SYSTEM 'CustomerCreate'>
<customer>
  <name>New Customer</name>
  <address>New Location</address>
</customer>

Step 9 - Delete a customer
------

We want to get rid of customers. For this we have to change little
in the 'custorms.ui' form: a button "Delete" with takes the following properties:
"action" set to "delete", "doctype" set to "CustomerDelete",
"rootelement" to "customer", "form" to "customers" (this is the simplest
way to reload the list of customers after the deletion) and "id" to
"{customer.id}":

(file:step9_customers_delete_button.png)

We add another map for the 'deleteCustomerDelete' request in 'tutorial.directmap':

deleteCustomerDelete = DeleteCustomer( xml );

A new 'CustomerDelete.simpleform' which allows us only the specify an 'id'
attribute of the customer to delete:

FORM CustomerDelete
{
	customer {
		id !@string
	}
}

and in 'tutorial.conf':

Processor {
	..
	program CustomerDelete.simpleform
	..
}

Finally follows the implementation of the delete transaction
in 'Customer.tdl':

TRANSACTION DeleteCustomer
BEGIN
	DO DELETE FROM Customer WHERE id=$(customer/id);
END

Executing the request we see in the qtclient debug output:

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE customer SYSTEM 'CustomerDelete'>
<customer id="3"/>

Seems ok, customer gone. :-)
