Requirements

You need the following packages:
- wolframe_0.0.1-1_amd64.deb: the Wolframe server
- wolframe-sqlite3_0.0.1-1_amd64.deb: the Sqlite3 database driver module
- wolframe-libxml2_0.0.1-1_amd64.deb: contains XML filter based on libxml2
- wolframe-client_0.0.1-1_amd64.deb: contains the Qt frontend

Sample application

We want to manage a list of customers with name and address and provide
the usual operations:
- list all customers
- create new customers
- edit existing customers
- view customer entries
- delete customers
- search for customers

Basic directory layout

We don't use the normal directory layout as it requires root rights to
install.

Instead we create two directories, one for server data and one for
client data:

mkdir ~/tutorial
mkdir ~/tutorial/server
mkdir ~/tutorial/client

Basic configuration

Step 1 - Basic connectivity
------

We have to set up the wolframed daemon with a running configuration file:

cd ~/tutorial/server

We create the central confuguration file of the server 'tutorial.conf':

(file:step1/server/tutorial.conf)

We can start the server now in the shell foreground with:

/usr/sbin/wolframed -f -c tutorial.conf

NOTICE: Starting server
DEBUG: Random generator initialized. Using device '/dev/urandom'
DEBUG: AAAA database references resolved
INFO: Accepting connections on ::1:7661
DEBUG: 1 network acceptor(s) created.
DEBUG: 0 network SSL acceptor(s) created.

The server is up and listening to port 7661. The server can be stopped
anytime by pressing 'Ctrl-C'.

If we use a telnet to connect to the server with

telnet localhost 7661

we get:

Access denied.

The server tells us:

DEBUG: Connection from ::1:52134 to localhost:7661 not authorized
DEBUG: Connection to ::1:52134 closed

Step 2 - AAAA
------

So we have to add a dummy authorization to the server configuration
which accepts all connections (not very secure, but for now good enough):

; dummy authorization
AAAA {
	Authorization {
		default allow
	}
}

If we start the server now, the telnet shows us

Escape character is '^]'.
Wolframe version 0.0.5 OS
OK

Enter 'quit' <Enter> now and we get back to the shell:

quit
BYE
Connection closed by foreign host.

Step 3 - The whole chain working
------

Now that we have ensured that basic connectivity to the Wolframe server
is available, we can configure the basics for the Qt client:

We copy the windows theme files MainWindow.ui and MainWindow.qss to
~/tutorial/client/themes/windows

We create a client configuration file ~/tutorial/client/client.conf with:

[wolframe]
host=localhost
port=7661
secure=false
checkSSL=true
client-cert-file=./certs/client.crt
client-key-file=./private/client.key
ca-cert-file=./certs/CAclient.cert.pem
uiloadmode=LocalFile
dataloadmode=Network
dbname=./apps/test/data.db
debug=false
uiFormDir=.
uiFormTranslationsDir=.
uiFormResourcesDir=.
dataLoaderDir=.
locale=en_US

now when we start the client with:

qtclient -s tutorial.conf -d

We get a login screen were we just hit "Login".

We get an empty window, we can go to "Help", "Debug Terminal". Also
here we can test the protocol as in a telnet client.

type "QUIT" <Enter> in the debug window or exit the Qt application over
the menu.

We start now the Qt designer and create an empty QWidget form named
'~/tutorial/client/init.ui' and save it. If we start the server now
we see the same empty window again, but this time it's the dynamically
loaded initial form (which is again empty).

Step 4 - Implement server side customer list
------

We want to store the customer data in a sqlite database, so we have to
prepare the server:

LoadModules {
	module /usr/lib/wolframe/modules/mod_db_sqlite3.so
}

This loads the database driver for Sqlite3. Now we also have to create
a database and populate the following schema:

CREATE TABLE Customer (
        id              INTEGER PRIMARY KEY AUTOINCREMENT,
        name            TEXT    NOT NULL,
        address         TEXT
);

Store this into schema.sql. Then execute:

sqlite3 tutorial.db < schema.sql

Now we have to tell server to use this sqlite database file:

database {
	SQLite {
		identifier	sqlitedb
		file		tutorial.db
		foreignKeys	yes
	}
}

When we restart the server we see:

DEBUG: SQLite database unit 'sqlitedb' created with 3 connections to file 'tutorial.db'

Now we want to use some XML filters to send/receive XML over the protocol,
so we have to add the following module to tutorial.conf:

LoadModules {
	..
	module /usr/lib/wolframe/modules/mod_filter_libxml2.so
	..
}

In order to see which modules are currently loaded in the wolframed we can
use:

wolframed -p -c tutorial.conf


We see:

..
Module files to load:
   /usr/lib/wolframe/modules/mod_db_sqlite3.so
   /usr/lib/wolframe/modules/mod_filter_libxml2.so
..

which looks ok.

For mapping the requests to programs we need the directmap module. First
add to tutorial.conf:

LoadModules {
	..
	module /usr/lib/wolframe/modules/mod_command_directmap.so
	..
}

and 

Processor {
	database sqlitedb
	cmdhandler {
		directmap {
			program tutorial.directmap
		}
	}
}

Now we have to a file 'tutorial.directmap'. This file maps
the requests to the corresponding transaction definitions:

CustomerListRequest = SelectCustomerList( xml );

This means that we map the 'CustomerListRequest' request which gives us a list
of customers to the TDL transaction 'SelectCustomerList'. This also means
we need to configure the TDL program in the server:

Processor {
	program Customer.tdl
}

The 'Customer.tdl' file contains the database transaction we want to execute.
We also specify that we want the result to be a 'list' which contains
'customer' tags with the data per customer:

TRANSACTION SelectCustomerList
RESULT INTO list
BEGIN
	INTO customer DO SELECT * from Customer;
END

We also need a validator for the input when the client sends a 'CustomerListRequest'.
we install the simple form DDL compilter in 'tutorial.conf' and register the
simpleform program to the list of programs:

LoadModules {
	..
	module /usr/lib/wolframe/modules/mod_ddlcompiler_simpleform.so
}

Program {
	..
	program CustomerListRequest.simpleform	
	..
}

and we add a simple form file 'CustomerListRequest.simpleform', for now we
can leave it empty but for the root element:

FORM CustomerListRequest
{
	customer {
	}
}

Now we create a telnet request, which contains basic authentication and
a request for the list of customers 'CustomerListRequest.netcat':

cat > CustomerListRequest.netcat
AUTH
MECH NONE
REQUEST
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE customer SYSTEM 'CustomerListRequest'>
<customer/>
.
QUIT
Ctrl-D

This we can execute with:

netcat -v --wait=2 127.0.0.1 7661 < CustomerListRequest.netcat

and we get:

Wolframe version 0.0.5 OS
OK
MECHS NONE
OK authorization
ANSWER
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<list><customer/></list>

.
OK REQUEST CustomerListRequest

We got an empty list of customers. So we have successfully configured
the server for our first command.

Let's also add some demo data now:

cat > data.sql
insert into customer(name,address) values('Dr Who','Blue Police Box');
insert into customer(name,address) values('John Smith','The Wheel in Space');
Ctrl-D

sqlite3 tutorial.db < data.sql

When we reexecute the netcat command we see:

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<list>
  <customer>
    <id>1</id>
    <name>Dr Who</name>
    <address>Blue Police Box</address>
  </customer>
  <customer>
    <id>2</id>
    <name>John Smith</name>
    <address>The Wheel in Space</address>
  </customer>
</list>

So, the data is now tra
We can move now to the qtclient to make our first request visible.

Step 5 - Implement client side customer list
------

It's time now to get something visual working, so we start to add a first
simple interface to our qtclient.

For this we need the 'Qt designer'. We open the file '~/tutorial/client/init.ui'
again and draw a single button with text "Customer List":

(file: step5_customer_button.png)

We add a dynamic property 'form' of type String to this button, which has
the value 'customers':

(file: step5_customer_button_form_property.png)

When we save the form and start the qtclient, we get (after logging in) the
first page with the "Customer List" button. Pressing it gives the error
message:

(file: step5_customer_button_pressed_error.png)

This means we have to define a new form called 'customers.ui', which will
show the list of customers, for now we leave it empty. When we start the
qtclient again and press the "Customer List" button again, we see that
qtclient again and press the "Customer List" button again, we see that
the form gets changed to "customer.ui" (empty).

We add now a QTreeWidget item to the customer.ui form and choose a grid layout
for the whole form. We change the name of the widget to 'customer':

(file: step5_customer_treewidget_and_name.png)

We also disable the 'rootIsDecorated' tick (we have a list, not a tree of customers).
We also set 'selectionMode' to 'SingleSelection' and 'selectionBehaviour'
to 'selectRows' to get the default expected behaviour of a list.

Now we change the columns of the list (by double clicking into the widget data area):

(file: step5_customer_column_names.png)

Now we add the 'doctype' and 'rootelement' dynamic properties to the
customer list widget, so that it loads the domain when the form is loaded.
The request to send is the 'CustomerListRequest' with root element 'customer'
we have configured before in the server:

(file:step5_customer_doctype_rootelement.png)
 
When we start the qtclient, we get a funny error message:

Error calling procedure: unknown attribute  (id) at /customer

This means we have to configure the id attribute in the server in the simpleform.
The qtclient adds a id automatically to the customer tag in the request.

We declare the customer to have an optional 'id' attribute in
'CustomerListRequest.simpleform':

FORM CustomerListRequest
{
	customer {
		id ?@string
	}
}

If we restart the server and run qtclient again we get the desired result:

(file:step5_customers_list.png)

Step 6 - Show Customer
------

As next step we want to show how data is communicated between the forms
by implementing a simple "show me customer data" use case.

Let's start by adding a button in 'customers.ui' called 'Show':

(file:step6_customers_edit_button.png)

We add dynamic properties, one is the 'form' which we set to 'customer_show'.
We want the currently selected customer to be accessible in the customer_show.ui
form, so we have to remember the current selection of the QTreeWidget named 'customer'
as global variable 'id'. We add a dynamic property with the name 'global.id' and
the value '{customer.id}':

(file:step6_customers_edit_button_props.png)

Now of course we have to create a new form called 'customer_show.ui'. We
choose a form layout and add two fields with labels 'Name:' and 'Address:'
and each of them having a QLineEdit widget. The names of the widgets
should be 'name' and 'address' in order to match the future read request
from the server. Temporarily we also add an 'id' field which shows us
the current value of 'global.id':

(file:step6_customer_show_id.png)

Finally we also need a button which brings us back to the customer list
by simply adding a 'form' action with the value 'customers':

(file:step6_customer_show_back_button.png)

If we start the qtclient and select a customer and press show we will
notice that the whole "Show Customer" form is empty, even the id. What's
wrong? Well, the widgets in qtclient have the default behaviour of using
'id' attributes attached to the colums of a list for instance. We must
make sure, the server is mapping us the XML correctly with 'id' attribute
and not 'id' as element.
