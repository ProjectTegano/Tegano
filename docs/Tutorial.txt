Requirements

You need the following packages:
- wolframe_0.0.1-1_amd64.deb: the Wolframe server
- wolframe-sqlite3_0.0.1-1_amd64.deb: the Sqlite3 database driver module
- wolframe-libxml2_0.0.1-1_amd64.deb: contains XML filter based on libxml2
- wolframe-client_0.0.1-1_amd64.deb: contains the Qt frontend

Sample application

We want to manage a list of customers with name and address and provide
the usual operations:
- list all customers
- create new customers
- edit existing customers
- view customer entries
- delete customers
- search for customers

Basic directory layout

We don't use the normal directory layout as it requires root rights to
install.

Instead we create two directories, one for server data and one for
client data:

mkdir ~/tutorial
mkdir ~/tutorial/server
mkdir ~/tutorial/client

Step 1 - Basic connectivity
------

We have to set up the wolframed daemon with a running configuration file:

cd ~/tutorial/server

We create the central confuguration file of the server 'tutorial.conf':

(file:step1/server/tutorial.conf)

We can start the server now in the shell foreground with:

/usr/sbin/wolframed -f -c tutorial.conf

NOTICE: Starting server
DEBUG: Random generator initialized. Using device '/dev/urandom'
DEBUG: AAAA database references resolved
INFO: Accepting connections on ::1:7661
DEBUG: 1 network acceptor(s) created.
DEBUG: 0 network SSL acceptor(s) created.

The server is up and listening to port 7661. The server can be stopped
anytime by pressing 'Ctrl-C'.

If we use a telnet to connect to the server with

telnet localhost 7661

we get:

Access denied.

The server tells us:

DEBUG: Connection from ::1:52134 to localhost:7661 not authorized
DEBUG: Connection to ::1:52134 closed

Step 2 - AAAA
------

So we have to add a dummy authorization to the server configuration
which accepts all connections (not very secure, but for now good enough):

; dummy authorization
AAAA {
	Authorization {
		default allow
	}
}

If we start the server now, the telnet shows us

Escape character is '^]'.
Wolframe version 0.0.5 OS
OK

Enter 'quit' <Enter> now and we get back to the shell:

quit
BYE
Connection closed by foreign host.

Step 3 - The whole chain working
------

Now that we have ensured that basic connectivity to the Wolframe server
is available, we can configure the basics for the Qt client:

We copy the windows theme files MainWindow.ui and MainWindow.qss to
~/tutorial/client/themes/windows

We create a client configuration file ~/tutorial/client/client.conf with:

[wolframe]
host=localhost
port=7661
secure=false
checkSSL=true
client-cert-file=./certs/client.crt
client-key-file=./private/client.key
ca-cert-file=./certs/CAclient.cert.pem
uiloadmode=LocalFile
dataloadmode=Network
dbname=./apps/test/data.db
debug=false
uiFormDir=.
uiFormTranslationsDir=.
uiFormResourcesDir=.
dataLoaderDir=.
locale=en_US

now when we start the client with:

qtclient -s tutorial.conf -d

We get a login screen were we just hit "Login".

We get an empty window, we can go to "Help", "Debug Terminal". Also
here we can test the protocol as in a telnet client.

type "QUIT" <Enter> in the debug window or exit the Qt application over
the menu.

We start now the Qt designer and create an empty QWidget form named
'~/tutorial/client/init.ui' and save it. If we start the server now
we see the same empty window again, but this time it's the dynamically
loaded initial form (which is again empty).

Step 4 - Implement server side customer list
------

We want to store the customer data in a sqlite database, so we have to
prepare the server:

LoadModules {
	module /usr/lib/wolframe/modules/mod_db_sqlite3.so
}

This loads the database driver for Sqlite3. Now we also have to create
a database and populate the following schema:

CREATE TABLE Customer (
        id              INTEGER PRIMARY KEY AUTOINCREMENT,
        name            TEXT    NOT NULL,
        address         TEXT
);

Store this into schema.sql. Then execute:

sqlite3 tutorial.db < schema.sql

Now we have to tell server to use this sqlite database file:

database {
	SQLite {
		identifier	sqlitedb
		file		tutorial.db
		foreignKeys	yes
	}
}

When we restart the server we see:

DEBUG: SQLite database unit 'sqlitedb' created with 3 connections to file 'tutorial.db'

Now we want to use some XML filters to send/receive XML over the protocol,
so we have to add the following module to tutorial.conf:

LoadModules {
	..
	module /usr/lib/wolframe/modules/mod_filter_libxml2.so
	..
}

In order to see which modules are currently loaded in the wolframed we can
use:

wolframed -p -c tutorial.conf


We see:

..
Module files to load:
   /usr/lib/wolframe/modules/mod_db_sqlite3.so
   /usr/lib/wolframe/modules/mod_filter_libxml2.so
..

which looks ok.

For mapping the requests to programs we need the directmap module. First
add to tutorial.conf:

LoadModules {
	..
	module /usr/lib/wolframe/modules/mod_command_directmap.so
	..
}

and 

Processor {
	database sqlitedb
	cmdhandler {
		directmap {
			program tutorial.directmap
		}
	}
}

Now we have to a file 'tutorial.directmap'. This file maps
the requests to the corresponding transaction definitions:

CustomerListRequest = SelectCustomerList( xml );

This means that we map the 'CustomerListRequest' request which gives us a list
of customers to the TDL transaction 'SelectCustomerList'. This also means
we need to configure the TDL program in the server:

Processor {
	program Customer.tdl
}

The 'Customer.tdl' file contains the database transaction we want to execute.
We also specify that we want the result to be a 'list' which contains
'customer' tags with the data per customer:

TRANSACTION SelectCustomerList
RESULT INTO list
BEGIN
	INTO customer DO SELECT * from Customer;
END

We also need a validator for the input when the client sends a 'CustomerListRequest'.
we install the simple form DDL compilter in 'tutorial.conf' and register the
simpleform program to the list of programs:

LoadModules {
	..
	module /usr/lib/wolframe/modules/mod_ddlcompiler_simpleform.so
}

Processor {
	..
	program CustomerListRequest.simpleform	
	..
}

and we add a simple form file 'CustomerListRequest.simpleform', for now we
can leave it empty but for the root element:

FORM CustomerListRequest
{
	customer {
	}
}

Now we create a telnet request, which contains basic authentication and
a request for the list of customers 'CustomerListRequest.netcat':

cat > CustomerListRequest.netcat
AUTH
MECH NONE
REQUEST
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE customer SYSTEM 'CustomerListRequest'>
<customer/>
.
QUIT
Ctrl-D

This we can execute with:

netcat -v --wait=2 127.0.0.1 7661 < CustomerListRequest.netcat

and we get:

Wolframe version 0.0.5 OS
OK
MECHS NONE
OK authorization
ANSWER
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<list><customer/></list>

.
OK REQUEST CustomerListRequest

We got an empty list of customers. So we have successfully configured
the server for our first command.

Let's also add some demo data now:

cat > data.sql
insert into customer(name,address) values('Dr Who','Blue Police Box');
insert into customer(name,address) values('John Smith','The Wheel in Space');
Ctrl-D

sqlite3 tutorial.db < data.sql

When we reexecute the netcat command we see:

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<list>
  <customer>
    <id>1</id>
    <name>Dr Who</name>
    <address>Blue Police Box</address>
  </customer>
  <customer>
    <id>2</id>
    <name>John Smith</name>
    <address>The Wheel in Space</address>
  </customer>
</list>

So, the data is now correctly retrieved from the database.

We can move now to the qtclient to make our first request visible.

Step 5 - Implement client side customer list
------

It's time now to get something visual working, so we start to add a first
simple interface to our qtclient.

For this we need the 'Qt designer'. We open the file '~/tutorial/client/init.ui'
again and draw a single button with text "Customer List":

(file: step5_customer_button.png)

We add a dynamic property 'form' of type String to this button, which has
the value 'customers':

(file: step5_customer_button_form_property.png)

When we save the form and start the qtclient, we get (after logging in) the
first page with the "Customer List" button. Pressing it gives the error
message:

(file: step5_customer_button_pressed_error.png)

This means we have to define a new form called 'customers.ui', which will
show the list of customers, for now we leave it empty. When we start the
qtclient again and press the "Customer List" button again, we see that
qtclient again and press the "Customer List" button again, we see that
the form gets changed to "customer.ui" (empty).

We add now a QTreeWidget item to the customer.ui form and choose a grid layout
for the whole form. We change the name of the widget to 'customer':

(file: step5_customer_treewidget_and_name.png)

We also disable the 'rootIsDecorated' tick (we have a list, not a tree of customers).
We also set 'selectionMode' to 'SingleSelection' and 'selectionBehaviour'
to 'selectRows' to get the default expected behaviour of a list.

Now we change the columns of the list (by double clicking into the widget data area):

(file: step5_customer_column_names.png)

Now we add the 'doctype' and 'rootelement' dynamic properties to the
customer list widget, so that it loads the domain when the form is loaded.
The request to send is the 'CustomerListRequest' with root element 'customer'
we have configured before in the server:

(file:step5_customer_doctype_rootelement.png)
 
When we start the qtclient, we get a funny error message:

Error calling procedure: unknown attribute  (id) at /customer

This means we have to configure the id attribute in the server in the simpleform.
The qtclient adds a id automatically to the customer tag in the request.

We declare the customer to have an optional 'id' attribute in
'CustomerListRequest.simpleform':

FORM CustomerListRequest
{
	customer {
		id ?@string
	}
}

If we restart the server and run qtclient again we get the desired result:

(file:step5_customers_list.png)

Step 6 - Show Customer
------

As next step we want to show how data is communicated between the forms
by implementing a simple "show me customer data" use case.

Let's start by adding a button in 'customers.ui' called 'Show':

(file:step6_customers_edit_button.png)

We add dynamic properties, one is the 'form' which we set to 'customer_show'.

We also add some signals for the double click on the customer list to
click the "Show" button:

(file:step6_customers_signals.png)

We want the currently selected customer to be accessible in the customer_show.ui
form, so we have to remember the current selection of the QTreeWidget named 'customer'
as global variable 'id'. We add a dynamic property with the name 'global.id' and
the value '{customer.id}':

(file:step6_customers_edit_button_props.png)

Now of course we have to create a new form called 'customer_show.ui'. We
choose a form layout and add two fields with labels 'Name:' and 'Address:'
and each of them having a QLineEdit widget. The names of the widgets
should be 'name' and 'address' in order to match the future read request
from the server. Temporarily we also add an 'id' field which shows us
the current value of 'global.id':

(file:step6_customer_show_id.png)

Finally we also need a button which brings us back to the customer list
by simply adding a 'form' action with the value 'customers':

(file:step6_customer_show_back_button.png)

If we start the qtclient and select a customer and press 'Show' we will
notice that the whole "Show Customer" form is empty, even the id. What's
wrong? Well, the widgets in qtclient have the default behaviour of using
'id' attributes attached to the colums of a list for instance. We must
make sure, the server is mapping us the XML correctly with 'id' attribute
and not 'id' as element.

This is the moment we go back to the server and start output form validation.
We add a 'CustomerList.simpleform' form which describes the result of the 'CustomerListRequest'
more precise and especially declares the 'id' as mandatory attribute of the customer:

FORM CustomerList
{
	list
	{
		customer []
		{
			id !@int
			name string
			address string
		}
	}
}

We have to declare output form validation in the 'CustomerListRequest'
in 'tutorial.directmap' as well:

CustomerListRequest = SelectCustomerList( xml ) : CustomerList;

and we have to include the program in 'tutorial.conf' of the server:

Processor {
	..
	program CustomerList.simpleform	
	..
}

Checking with:

netcat -v --wait=2 127.0.0.1 7661 < CustomerListRequest.netcat

we get now:

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE list SYSTEM "CustomerList.simpleform">
<list>
  <customer id="1">
    <name>Dr Who</name>
    <address>Blue Police Box</address>
  </customer>
  <customer id="2">
    <name>John Smith</name>
    <address>The Wheel in Space</address>
  </customer>
</list>

So, that looks ok.

Now also the qtlient shows the id of the customer, when the user double
clicks the customer in the list.

The 'name' and the 'address' fields are still empty. We could of course
use global variables again to propagate the values between forms, but
if the form gets more complex, this is not a good idea.

We start to use the 'initAction' property on the 'customer_show.ui' form
as follows: we want it to execute a read with a document type 'CustomerRequest'
which searches for a single customer by customer id:

(file:step6_customer_show_initaction.png)

We see, that we use the value of 'global.id' again and add it to the 'initAction'
request as attribute 'id' (we can use the qtclient with -d to see the communication
on the wire):

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE customer SYSTEM 'CustomerRequest'>
<customer id="2"/>

We also get in the client:

CRITICAL: ERROR: error in network data loader "Protocol error in command REQUEST, received:  no command handler for 'CustomerRequest'." 

and in the server:

ERROR: error redirect input: no command handler for 'CustomerRequest'

We see, that the request is sent to the server, but we didn't define the
necessary things in the server yet. So we add another map:

CustomerRequest = SelectCustomer( xml ) : Customer;

to 'tutorial.directmap'.

We define a new file 'CustomerRequest.simpleform' which contains the
validation of the customer request (for now, this looks exactly like
the request for the list of customers, but we may want to change that
later):

FORM CustomerRequest
{
	customer {
		id ?@string
	}
}

We register the form in 'tutorial.conf':

Processor {
	..
	program CustomerRequest.simpleform
	..
}

And of course we have to define a transaction function 'SelectCustomer'
in 'Customer.tdl':

TRANSACTION SelectCustomer
RESULT INTO customer
BEGIN
	INTO . DO SELECT * from Customer WHERE id=$(customer/id);
END

The '$(customer/id)' refers to the ID we pass down for the customer record
to retrieve. The 'RESULT INTO customer' makes sure the result will again
be in a table with 'customer' as root element.

We also have to define how the result should be mapped, so:

Processor {
	..
	program Customer.simpleform
	..
}

and 'Customer.sumpleform':

FORM Customer
{
	customer
	{
		id !@string
		name string
		address string
	}
}

Now if we restart client and server and we click on the second
customer in the list we get:

(file:step6_customer_show_working.png)

So we successfully read the data of a customer into a form.

Step 7 - Editing customer
------

We change the show customer use case slightly, so that we can also
edit the customer in the customer_show.ui form.

Let's first make a copy of 'customer_show.ui' and name it 'customer_edit.ui'.

As before we add first a "Edit" button to the 'customers.ui' with 'forms'
set to 'customer_edit' and 'global.id' set to '{customer.id}':

(file:step7_customers_edit_button.png)

We change the form 'customer_edit.ui' and remove the line with 'ID' as we
don't need it anymore and because nobody should be able to edit the id of
a customer and change it! We also add another button and label it 'Save',
this button get the properties 'form' set to 'customers', 'action' set to
'update', 'doctype' to 'CustomerUpdate', 'rootelement' to 'customer' and
'id' to '{global.id}':

(file:step7_customer_edit.png)

The other fields will be sent along automatically in the 'CustomerUpdate' XML request:

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE customer SYSTEM 'CustomerUpdate'>
<customer id="2">
  <name>John Smith</name>
  <address>The Wheel in Space</address>
</customer>

Similar to to the "show customer" case we add now a new map:

editCustomerUpdate = UpdateCustomer( xml );

We also add a simple form 'CustomerUpdate.simpleform' which looks very similar
to the 'Customer.simpleform':

FORM CustomerUpdate
{
	customer
	{
		id !@string
		name string
		address string
	}
}

add it to 'tutorial.conf':

Processor {
	...
	program CustomerUpdate.simpleform
	...
}

finally we write the transaction function 'CustomerUpdate' in 'Customer.tdl':

TRANSACTION UpdateCustomer
BEGIN
	DO UPDATE Customer SET name=$(customer/name), address=$(customer/address)
		WHERE id=$(customer/id);
END

Note, that this time the database transaction doesn't return a result.

Restart server and client and start to edit the customers.

Step 8 - Add a new customer
------

We also want to add new customers to the list. The "add customer" case
is very similar to the "edit customer" case.

Let's copy the 'customer_edit.ui' to 'customer_add.ui'. We remove the
'initAction' and the other dynamic properties from the form itself as
we don't want to read anything when creating a new customer. But of course
we could execute here a "Get new customer initial data" request too which
initializes certain values.

We change the "Save" button and rename it to "Add". We also change the
documenttype there from "CustomerUpdate" to 'CustomerCreate' and we remove
the 'id' property (as this one is automatically choosen by the sequence
in the database). We also have to chaqnge the 'action' from 'update' to
'create':

(file:step8_customer_add.png)

We also introduce a new element here, the 'initalFocus' property. We
set it on the 'name' QLineWidget, so that it gets the initial keyboard
focus when the form is loaded:

(file:step8_customer_add_name_initial_focus.png)

In the 'customers.ui' form we have to add a 'Add' button which has one
property 'form' with value 'customer_add':

(file:step8_customers_add_button.png)

Now for the server side. We add a new mapping for customer creation
in 'tutorial.directmap':

editCustomerUpdate = UpdateCustomer( xml );
createCustomerCreate = CreateCustomer( xml );

We also have to add the simple form 'CustomerCreate.simpleform':

FORM CustomerCreate
{
	customer
	{
		name string
		address string
	}
}

This is the same as 'CustomerUpdate.simpleform' with the exception that
we don't accept an 'id' attribute to be passed to the server.

We register this form in 'tutorial.conf':

Processor {
	..
	program CustomerCreate.simpleform
	..
}

Last we add a 'CreateCustomer' transaction function:

TRANSACTION CreateCustomer
BEGIN
	DO INSERT INTO Customer( name, address )
		VALUES( $(customer/name), $(customer/address) );
END

When we restart the server and client we see the following request
being passed to the wolframe server:

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE customer SYSTEM 'CustomerCreate'>
<customer>
  <name>New Customer</name>
  <address>New Location</address>
</customer>

Step 9 - Delete a customer
------

We want to get rid of customers. For this we have to change little
in the 'custorms.ui' form: a button "Delete" with takes the following properties:
"action" set to "delete", "doctype" set to "CustomerDelete",
"rootelement" to "customer", "form" to "customers" (this is the simplest
way to reload the list of customers after the deletion) and "id" to
"{customer.id}":

(file:step9_customers_delete_button.png)

We add another map for the 'deleteCustomerDelete' request in 'tutorial.directmap':

deleteCustomerDelete = DeleteCustomer( xml );

A new 'CustomerDelete.simpleform' which allows us only the specify an 'id'
attribute of the customer to delete:

FORM CustomerDelete
{
	customer {
		id !@string
	}
}

and in 'tutorial.conf':

Processor {
	..
	program CustomerDelete.simpleform
	..
}

Finally follows the implementation of the delete transaction
in 'Customer.tdl':

TRANSACTION DeleteCustomer
BEGIN
	DO DELETE FROM Customer WHERE id=$(customer/id);
END

Executing the request we see in the qtclient debug output:

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE customer SYSTEM 'CustomerDelete'>
<customer id="3"/>

Seems ok, customer gone. :-)
